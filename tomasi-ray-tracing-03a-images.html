<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Maurizio Tomasi maurizio.tomasi@unimi.it">
  <title>Lezione 3</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/theme/white.css" id="theme">
  <link rel="stylesheet" href="./css/custom.css"/>
  <link rel="stylesheet" href="./css/asciinema-player.css"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Lezione 3</h1>
  <p class="subtitle">Calcolo numerico per la generazione di immagini fotorealistiche</p>
  <p class="author">Maurizio Tomasi <a href="mailto:maurizio.tomasi@unimi.it" class="email">maurizio.tomasi@unimi.it</a></p>
</section>

<section id="immagini-hdr-e-ldr" class="slide level1">
<h1>Immagini HDR e LDR</h1>
</section>
<section id="da-rgb-a-srgb" class="slide level1">
<h1>Da RGB a sRGB</h1>
<ul>
<li><p>Nella scorsa lezione abbiamo visto che l’equazione del rendering si riscrive naturalmente nelle componenti di colore R, G e B.</p></li>
<li><p>I dispositivi di visualizzazione (monitor, schermi di tablet, televisori) richiedono però l’uso di sRGB, che ha i seguenti limiti:</p>
<ul>
<li>Le componenti R, G e B sono numeri interi in un intervallo limitato;</li>
<li>La risposta dei dispositivi non è lineare.</li>
</ul></li>
<li><p>Il <em>tone mapping</em> è il processo attraverso cui si converte un’immagine RGB in un’immagine sRGB, dove per <em>immagine</em> si intende una matrice di colori RGB.</p></li>
</ul>
</section>
<section id="obbiettivo-del-corso" class="slide level1">
<h1>Obbiettivo del corso</h1>
<p><img data-src="pd-images/efb75bb8bf876b0141713bed8c2a0501fc00e1cc.svg" data-im_fname="course-workflow" /></p>
</section>
<section id="formati-grafici" class="slide level1">
<h1>Formati grafici</h1>
<ul>
<li><p>Nella prossima esercitazione inizieremo la nostra implementazione dal fondo, ossia il salvataggio dell’immagine.</p></li>
<li><p>A seconda del tipo di immagine (foto, grafico, disegno a mano libera), il formato del salvataggio cambia.</p></li>
<li><p>Un’immagine fotorealistica dovrebbe essere indistinguibile da quella prodotta da una fotocamera.</p></li>
<li><p>In che modo una fotocamera registra in un file un’immagine?</p></li>
</ul>
</section>
<section id="salvataggio-di-immagini" class="slide level1">
<h1>Salvataggio di immagini</h1>
<ul>
<li><p>Esistono due famiglie di file grafici:</p>
<ul>
<li>Grafica vettoriale: SVG, PDF, EPS, AI…</li>
<li>Grafica raster (matriciale): JPEG, PNG, GIF, RAW…</li>
</ul></li>
<li><p>I file <strong>vettoriali</strong> contengono istruzioni per disegnare un’immagine:</p>
<pre class="text"><code>- cerchio centrato in (3.5, 2.6) con raggio 1.5 di colore nero
- linea da (1.1, 1.7) a (3.7, 7.4) di colore nero con spessore 2
- etc.</code></pre></li>
<li><p>I file <strong>raster</strong> salvano una matrice di colori, e sono quelli che ci interessano per questo corso, perché sono i file salvati dalle fotocamere.</p></li>
</ul>
</section>
<section class="slide level1">

<center>
<img data-src="./media/difference-between-raster-and-vector-image.png" />
</center>
</section>
<section id="grafica-vettoriale" class="slide level1">
<h1>Grafica vettoriale</h1>
<center>
<img data-src="./media/Carnot-cycle-p-V-diagram.svg" />
</center>
</section>
<section id="grafica-raster" class="slide level1">
<h1>Grafica raster</h1>
<center>
<img data-src="./media/gilles_tran.jpg" />
</center>
</section>
<section id="tipi-di-immagini-raster" class="slide level1">
<h1>Tipi di immagini raster</h1>
<p>Ci sono due categorie di immagini raster che sono rilevanti per questo corso:</p>
<dl>
<dt>Immagini LDR (Low-Dynamic Range)</dt>
<dd>Codificano i colori usando il sistema sRGB: le tre componenti R, G, B sono quindi numeri interi, solitamente nell’intervallo 0–255. Tutti i formati grafici più diffusi (JPEG, PNG, GIF, etc.) appartengono a questo tipo.
</dd>
<dt>Immagini HDR (High-Dynamic Range)</dt>
<dd>Codificano i colori usando il sistema RGB o sRGB, ma le tre componenti R, G, B sono numeri floating-point e coprono quindi un grande intervallo dinamico; per visualizzarle occorre quindi applicare il <em>tone mapping</em>. Esempi di questo formato sono OpenEXR e PFM.
</dd>
</dl>
</section>
<section id="codifica-di-immagini-raster" class="slide level1">
<h1>Codifica di immagini raster</h1>
<ul>
<li><p>Sia le immagini LDR che HDR sono codificate tramite una matrice di colori; ogni colore è solitamente una terna (R, G, B).</p></li>
<li><p>Il file ha solitamente questo contenuto:</p>
<dl>
<dt>Header</dt>
<dd>Specifica il formato dell’immagine, le dimensioni della matrice, e a volte anche altri parametri utili (es., la data e l’ora dello scatto, le coordinate del GPS, il valore di <span class="math inline">\gamma</span> del dispositivo che ha catturato l’immagine, etc.).
</dd>
<dt>Matrice dei colori</dt>
<dd>L’ordine in cui sono salvate le righe/colonne, e anche l’ordine in cui sono salvate le componenti R, G, B (RGB/BGR) varia a seconda del formato.
</dd>
</dl></li>
</ul>
</section>
<section class="slide level1">

<center>
<img data-src="./media/image-save-order.svg" />
</center>
</section>
<section id="esempio-il-formato-ppm" class="slide level1">
<h1>Esempio: il formato PPM</h1>
<ul>
<li><p>Formato LDR, molto diffuso sui sistemi Unix.</p></li>
<li><p>Potete leggerlo e scriverlo usando <a href="http://netpbm.sourceforge.net/">NetPBM</a> o <a href="https://imagemagick.org/index.php">ImageMagick</a>. Il secondo è il più diffuso, e può essere installato con</p>
<pre class="text"><code>$ sudo apt install imagemagick</code></pre>
<p>Potete convertire immagini col comando</p>
<pre class="text"><code>$ convert input.png output_p6.ppm                  # Formato P6
$ convert input.jpg -compress none output_p3.ppm   # Formato P3</code></pre></li>
<li><p>PPM è un formato pensato per essere scritto e letto facilmente.</p></li>
</ul>
</section>
<section id="file-ppm-p3" class="slide level1">
<h1>File PPM (P3)</h1>
<ul>
<li><p>Un file PPM è un file di testo, apribile con qualsiasi editor.</p></li>
<li><p><strong>Header</strong>:</p>
<ol type="1">
<li>I due caratteri <code>P3</code>;</li>
<li>Numero di colonne e di righe, in formato testo e separate da uno spazio;</li>
<li>Valore massimo per ciascuna delle componenti R, G, B (solitamente 255).</li>
</ol></li>
<li><p><strong>Matrice dei colori</strong>: le terne R, G, B devono essere riportate come numeri interi partendo dall’angolo in alto a sinistra a quello in basso a destra, procedendo riga per riga.</p></li>
</ul>
</section>
<section id="esempio-p3" class="slide level1">
<h1>Esempio (P3)</h1>
<pre class="text"><code>P3
3 2
255
255   0   0
  0 255   0
  0   0 255
255 255   0
255 255 255
  0   0   0</code></pre>
<center>
<img data-src="./media/tiny-image-6pixels.png" />
</center>
</section>
<section id="file-ppm-p6" class="slide level1">
<h1>File PPM (P6)</h1>
<ul>
<li><p>Oltre al tipo <code>P3</code> esiste anche il file di tipo <code>P6</code>.</p></li>
<li><p>La differenza sta nel modo in cui le terne R, G, B sono salvate: invece di scrivere numeri in codifica testuale, vengono scritti in binario.</p></li>
<li><p>Vedremo dopo questa differenza, che sarà però fondamentale per l’esercitazione di questa settimana.</p></li>
</ul>
</section>
<section id="file-pfm" class="slide level1">
<h1>File PFM</h1>
<ul>
<li><p>È un tipo di file che si ispira a PPM, ma è un formato HDR</p></li>
<li><p><strong>Molto</strong> importante per questo corso!</p></li>
<li><p>Non è così ben supportato: sotto Ubuntu esiste solo <code>pftools</code>, che si installa con</p>
<pre class="text"><code>$ sudo apt install pftools</code></pre></li>
<li><p>Noi scriveremo i nostri tool che permetteranno di convertire file PFM in PPM.</p></li>
</ul>
</section>
<section id="struttura-di-un-file-pfm" class="slide level1">
<h1>Struttura di un file PFM</h1>
<ul>
<li><p>Come i file PPM in formato P6, anche i file PFM sono parzialmente di testo e parzialmente binari.</p></li>
<li><p><strong>Header</strong>:</p>
<ol type="1">
<li>I due caratteri <code>PF</code>, più il carattere <code>0x0a</code> (ritorno a capo);</li>
<li><code>ncol nrows</code> (colonne e righe), seguito da ritorno a capo <code>0x0a</code>;</li>
<li>Il valore <code>-1.0</code>, seguito da <code>0x0a</code>.</li>
</ol></li>
<li><p><strong>Matrice dei colori</strong>: le terne R, G, B devono essere scritte come sequenze di numeri a 32 bit (quindi <strong>non</strong> testo!), da sinistra a destra e dal <strong>basso all’alto</strong> (diverso da PPM!).</p></li>
</ul>
</section>
<section id="codifica-testuale-e-binaria" class="slide level1">
<h1>Codifica testuale e binaria</h1>
</section>
<section id="codifica-binaria" class="slide level1">
<h1>Codifica binaria</h1>
<ul>
<li><p>I file binari sono il tipo più semplice: consistono di una sequenza di byte (ossia, 8 bit scritti in sequenza).</p></li>
<li><p>Ogni byte può contenere un valore intero nell’intervallo 0–255</p></li>
<li><p>Per stampare il contenuto di un file binario potete usare il comando <code>xxd</code> (sotto Ubuntu, installatelo con <code>sudo apt install xxd</code>):</p>
<pre class="text"><code>$ xxd file.bin</code></pre>
<p>(Su altri sistemi operativi potreste avere <code>hexdump</code> anziché <code>xxd</code>).</p></li>
<li><p>Salvare dati in un file binario vuol dire scrivere una sequenza di numeri binari sul disco fisso, memorizzati come byte.</p></li>
</ul>
</section>
<section id="da-binario-a-decimale" class="slide level1">
<h1>Da binario a decimale</h1>
<ul>
<li><p>Per ragionare sui valori dei byte si usa la numerazione binaria, che ovviamente usa come base il numero 2:</p>
<pre><code>0  → 0
1  → 1
2  → 10
3  → 11
4  → 100
…</code></pre></li>
<li><p>Per un numero <code>dcba</code> espresso in una base <span class="math inline">B</span>, il suo valore è</p>
<p><span class="math display">
\text{value} = a \times B^0 + b \times B^1 + c \times B^2 + d \times B^3.
</span></p>
<p>Quindi il valore binario <code>101</code> corrisponde a <span class="math inline">1 \times 2^0 + 0 \times 2^1 + 1\times 2^2 = 5.</span></p></li>
</ul>
</section>
<section id="notazione-ottale" class="slide level1">
<h1>Notazione ottale</h1>
<ul>
<li><p>La notazione binaria è comoda per una CPU ma scomoda per noi!</p></li>
<li><p>Una base più comoda è quella ottale (8).</p></li>
<li><p>In C/C++, le cifre ottali si scrivono facendole precedere da <code>0</code>.</p></li>
<li><p>Siccome <span class="math inline">8 = 2^3</span>, una cifra ottale corrisponde a 3 cifre binarie. Basta imparare a memoria l’associazione binario-ottale per i numeri da 0 a 7 per saper convertire ogni altro valore:</p>
<pre><code>03  -&gt; 011
06  -&gt; 110
036 -&gt; 011 110</code></pre>
<p>La conversione inversa è ugualmente semplice.</p></li>
</ul>
</section>
<section id="notazione-esadecimale" class="slide level1">
<h1>Notazione esadecimale</h1>
<ul>
<li><p>La notazione ottale è però scomoda, perché i computer lavorano a multipli di 8 bit (i byte), mentre la notazione ottale usa 3 bit per cifra.</p></li>
<li><p>Oggi la notazione ottale è quasi completamente abbandonata in favore della notazione esadecimale (16), che usa le cifre</p>
<pre><code>0 1 2 3 4 5 6 7 8 9 A B C D E F</code></pre></li>
<li><p>La notazione esadecimale richiede 4 bit per cifra, perché <span class="math inline">2^4 = 16</span>. Siccome un byte è composto da 8 bit, il valore di un byte è sempre codificabile usando solo due cifre esadecimali (<code>0xFF = 255</code>).</p></li>
<li><p>In C/C++/Julia/C#, i numeri esadecimali si scrivono facendoli iniziare con <code>0x</code>, ad es. <code>0x1F67 = 8039</code>.</p></li>
</ul>
</section>
<section id="ordine-dei-bit-in-un-byte" class="slide level1">
<h1>Ordine dei bit in un byte</h1>
<ul>
<li><p>C’è sempre un’ambiguità di fondo nel raggruppamento dei bit in byte, e sta nel loro ordine.</p></li>
<li><p>Se un byte è formato dalla sequenza di bit <code>0011 0101</code>, esistono due modi per interpretarlo:</p>
<p><span class="math display">
\begin{aligned}
2^2 + 2^3 + 2^5 + 2^7 &amp;= 172,\\
2^5 + 2^4 + 2^2 + 2^0 &amp;= 53.
\end{aligned}
</span></p></li>
</ul>
</section>
<section id="endianness-dei-bit" class="slide level1">
<h1>«Endianness» dei bit</h1>
<ul>
<li><p>L’ordine dei bit in un byte è detto in gergo <em>bit-endianness</em>, termine tratto dai <em>Viaggi di Gulliver</em> (1726), di J. Swift:</p>
<ol type="1">
<li>La codifica <em>big-endian</em> parte dalla potenza <em>maggiore</em> («big»);</li>
<li>La codifica <em>little-endian</em> parte dalla potenza <em>minore</em> («little»).</li>
</ol></li>
<li><p>Le CPU Intel e AMD oggi usate nei personal computer usano tutte la codifica <em>little-endian</em>. La codifica <em>big-endian</em> è stata molto usata in passato, ma oggi è ancora impiegata in alcune CPU ARM.</p></li>
</ul>
</section>
<section id="salvare-dati-in-binario" class="slide level1">
<h1>Salvare dati in binario</h1>
<ul>
<li><p>Salvare una variabile in forma binaria non è in generale semplice!</p></li>
<li><p>In C++ ad esempio, il programma seguente <em>non</em> salva il valore di <code>x</code> in binario:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;fstream&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x<span class="op">{</span><span class="dv">138</span><span class="op">};</span>  <span class="co">// 138 &lt; 256, so the value fits in *one* byte</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>ofstream<span class="op"> </span>outf<span class="op">{</span><span class="st">&quot;file.bin&quot;</span><span class="op">};</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  outf <span class="op">&lt;&lt;</span> x<span class="op">;</span> <span class="co">// Ouch! It writes *three* bytes: &#39;1&#39;, &#39;3&#39;, &#39;8&#39;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p>Il valore <code>138</code> è stato salvato in <em>forma testuale</em>. (Se includete <code>&lt;cstdint&gt;</code> e cambiate il tipo di <code>x</code> da <code>int</code> a <code>uint8_t</code>, il valore viene salvato come binario!)</p></li>
<li><p>Vediamo in cosa consiste la codifica testuale.</p></li>
</ul>
</section>
<section id="codifica-testuale" class="slide level1">
<h1>Codifica testuale</h1>
<ul>
<li><p>I caratteri del computer vengono codificati tramite dei valori precisi; le lettere dell’alfabeto latino, le cifre romane e la punteggiatura di base usano la codifica ASCII:</p>
<ul>
<li>La lettera <code>A</code> è codificata dal numero 65, <code>B</code> da 66, <code>C</code> da 67, etc.;</li>
<li>La lettera <code>a</code> è codificata dal numero 97, <code>b</code> da 98, etc.;</li>
<li>La cifra <code>0</code> è codificata dal numero 48, <code>1</code> da 49, etc.</li>
</ul></li>
<li><p>Codificare una parola come <code>Casa</code> vuol dire rappresentare la parola con la sequenza di valori <code>67 97 115 97</code>.</p></li>
<li><p>Questi codici numerici fanno parte dello standard ASCII, che specifica 128 caratteri. (<a href="https://garbagecollected.org/2017/01/31/four-column-ascii/">Qui c’è la tabella completa</a>, spiegata bene).</p></li>
</ul>
</section>
<section id="codifica-di-testi" class="slide level1">
<h1>Codifica di testi</h1>
<ul>
<li><p>Lo standard ASCII è semplicissimo, eppure sufficiente per codificare testi:</p>
<pre class="text"><code>Beauty - be not caused - It Is -
Chase it, and it ceases -
Chase it not, and it abides -
Overtake the Creases

In the Meadow - when the Wind
Runs his fingers thro’ it -
Deity will see to it
That You never do it -

(Emily Dickinson)</code></pre></li>
<li><p>Ma come si codifica la fine della riga in ogni verso della poesia?</p></li>
<li><p>In 128 valori è possibile codificare <em>tutti</em> i caratteri?</p></li>
</ul>
</section>
<section id="ritorno-a-capo" class="slide level1">
<h1>Ritorno a capo</h1>
<ul>
<li><p>Il modo per indicare un ritorno a capo dipende dal sistema operativo!</p></li>
<li><p>Nelle macchine da scrivere c’erano due operazioni da fare per iniziare una nuova riga (vedi <a href="https://www.youtube.com/watch?v=r97JHr13T98">questo video YouTube</a>):</p>
<ol type="1">
<li>Spostarsi verso il bordo sinistro/destro del foglio (<em>carriage return</em>);</li>
<li>Muoversi alla riga successiva (<em>line feed</em>).</li>
</ol></li>
<li><p>Anche i computer hanno adottato questi due comandi, che corrispondono a due valori ASCII: <code>13</code> (<em>carriage return</em>, indicato anche come <code>\r</code>) e <code>10</code> (<em>line feed</em>, indicato con <code>\n</code>).</p></li>
</ul>
</section>
<section id="tipi-di-ritorno-a-capo" class="slide level1">
<h1>Tipi di ritorno a capo</h1>
<ul>
<li><p>Il tipo di ritorno a capo dipende dal sistema operativo utilizzato:</p>
<table>
<thead>
<tr class="header">
<th>Sistema operativo</th>
<th>Codifica</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Windows, DOS</td>
<td><code>13 10</code> (<code>\r\n</code>)</td>
</tr>
<tr class="even">
<td>RISC OS</td>
<td><code>10 13</code> (<code>\n\r</code>)</td>
</tr>
<tr class="odd">
<td>C64, macOS classic</td>
<td><code>13</code> (<code>\r</code>)</td>
</tr>
<tr class="even">
<td>Linux, Mac OS X</td>
<td><code>10</code> (<code>\n</code>)</td>
</tr>
</tbody>
</table></li>
<li><p>Si può convertire un file con i comandi <code>dos2unix</code> e <code>unix2dos</code>.</p></li>
<li><p>Git si aspetta il formato Linux (<code>\n</code>), ed emette un warning se i file aggiunti con <code>git add</code> ne usano un altro.</p></li>
</ul>
</section>
<section id="da-ascii-a-unicode" class="slide level1">
<h1>Da ASCII a Unicode</h1>
<ul>
<li><p>ASCII è stato usato per la prima volta su un terminale che usava 7 bit per byte: ecco perché l’ultimo carattere ha valore <code>127 = 0x7F</code> (<span class="math inline">127 = 2^7 - 1</span>).</p></li>
<li><p>Nei 128 caratteri sono inclusi anche caratteri «speciali», come il ritorno a capo (<code>10</code>), la tabulazione (<code>8</code>), etc., che «consumano» posizioni nella tabella.</p></li>
<li><p>ASCII è un sistema centrato sul sistema di scrittura usato negli USA, e non include caratteri accentati come «è», «é», «ü», «â», etc.</p></li>
<li><p>Oltre agli accenti sulle lettere latine, sono esistenti nel mondo molti altri alfabeti e simboli (greco, cirillico, cinese, i simboli matematici, etc.).</p></li>
<li><p>Lo standard Unicode ha esteso ASCII per includere <em>tutte</em> i possibili simboli testuali (contiene anche i geroglifici egizi e il sumerico!).</p></li>
</ul>
</section>
<section id="lo-standard-unicode" class="slide level1">
<h1>Lo standard Unicode</h1>
<ul>
<li><p>Standard internazionale nato nel 1991, che copre praticamente tutti i sistemi di scrittura oggi esistenti al mondo.</p></li>
<li><p>Oggi è supportato quasi universalmente.</p></li>
<li><p>Viene aggiornato periodicamente, circa una volta all’anno.</p></li>
</ul>
<center>
<img data-src="./media/unicode-example.png" />
</center>
</section>
<section id="versioni-unicode" class="slide level1">
<h1>Versioni Unicode</h1>
<table>
<thead>
<tr class="header">
<th>Versione</th>
<th>Data</th>
<th>Scritture</th>
<th>Caratteri</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1.0</td>
<td>Ottobre 1991</td>
<td>24</td>
<td>7,129</td>
</tr>
<tr class="even">
<td>…</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>11.0</td>
<td>Giugno 2018</td>
<td>146</td>
<td>137,374</td>
</tr>
<tr class="even">
<td>12.0</td>
<td>Marzo 2019</td>
<td>150</td>
<td>137,928</td>
</tr>
<tr class="odd">
<td>13.0</td>
<td>Marzo 2020</td>
<td>154</td>
<td>143,859</td>
</tr>
</tbody>
</table>
</section>
<section id="esempi-di-caratteri-unicode" class="slide level1">
<h1>Esempi di caratteri Unicode</h1>
<ul>
<li>Lettera A maiuscola: <code>A</code> (65, uguale all’ASCII!);</li>
<li>Lettera A minuscola con accento acuto: <code>à</code> (224);</li>
<li>Lettera E maiuscola con accento grave: <code>É</code> (201);</li>
<li>Puntini di sospensione: <code>…</code> (8230);</li>
<li>Bemolle: <code>♭</code> (9837);</li>
<li>Faccina che ride: <code>😀</code> (128.512).</li>
</ul>
</section>
<section id="codifica-unicode" class="slide level1">
<h1>Codifica Unicode</h1>
<ul>
<li><p>Ogni carattere Unicode è associato a un valore numerico, chiamato <em>code point</em>.</p></li>
<li><p>Si possono <a href="https://en.wikipedia.org/wiki/Combining_character">combinare insieme caratteri</a>: unendo <code>a</code> e <code>^</code> per formare <code>â</code>.</p></li>
<li><p>Le lettere accentate più comuni hanno però una <a href="https://en.wikipedia.org/wiki/Precomposed_character">codifica dedicata</a>. Queste lettere sono quindi codificabili in <strong>più modi</strong> secondo lo standard Unicode. (Questo rende complicato confrontare due stringhe!)</p></li>
<li><p>Un <em>grafema</em> è il risultato di una combinazione di uno o più code point. Quindi la parola <code>così</code> è composta da quattro grafemi: <code>c</code>, <code>o</code>, <code>s</code> ed <code>ì</code> (che può essere il <em>code point</em> 236, oppure la combinazione dei code point <code>i</code> e `).</p></li>
<li><p>La combinazione di caratteri diversi è molto importante in certe scritture come il cinese.</p></li>
</ul>
</section>
<section id="codificare-i-code-point" class="slide level1">
<h1>Codificare i <em>code point</em></h1>
<ul>
<li><p>Lo standard Unicode possiede molti <em>code point</em>, e a ogni versione se ne aggiungono di nuovi.</p></li>
<li><p>Questo pone un problema nella codifica dei <em>code point</em> su file: ASCII usava un byte per carattere perché il set era limitato. Ma per Unicode quanti byte per <em>code point</em> usare? 1? 2? 100?</p>
<ul>
<li>Se si scegliesse un valore basso, si limiterebbe l’estendibilità di Unicode.</li>
<li>Se si scegliesse un valore molto alto, i file di testo aumenterebbero di dimensione inutilmente: la poesia di E. Dickinson richiede 232 byte in codifica ASCII (un byte per carattere). Usare 4 byte per carattere quadruplicherebbe lo spazio.</li>
</ul></li>
</ul>
</section>
<section id="codifiche-oggi-usate" class="slide level1">
<h1>Codifiche oggi usate</h1>
<ul>
<li><p>Storicamente sono state proposte varie codifiche per Unicode.</p></li>
<li><p>Le più usate oggi sono le codifiche UTF (Unicode Transformation Format), che esistono in tre versioni:</p>
<ul>
<li>UTF8 (usata nei sistemi Linux e Mac OS X);</li>
<li>UTF16 (usata in Windows);</li>
<li>UTF32 (molto comoda dal punto di vista del software).</li>
</ul></li>
</ul>
</section>
<section id="utf-8" class="slide level1">
<h1>UTF-8</h1>
<ul>
<li><p>È oggi la codifica più usata in assoluto (tranne che sotto Windows 😢).</p></li>
<li><p>Il numero di byte usati per un <em>code point</em> è variabile da 1 a 4.</p></li>
<li><p>È compatibile con la codifica ASCII: un file ASCII è automaticamente anche un file UTF-8 valido, perché sfrutta il fatto che la codifica ASCII usa solo 7 degli 8 bit in un byte, e che i primi 127 <em>code point</em> Unicode sono uguali ai valori ASCII.</p></li>
</ul>
</section>
<section id="codifica-utf-8" class="slide level1">
<h1>Codifica UTF-8</h1>
<table>
<thead>
<tr class="header">
<th>Code point</th>
<th>Byte 1</th>
<th>Byte 2</th>
<th>Byte 3</th>
<th>Byte 4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>0x0000</code>–<code>0x007F</code></td>
<td><code>0xxxxxxx</code></td>
<td>—</td>
<td>—</td>
<td>—</td>
</tr>
<tr class="even">
<td><code>0x0080</code>–<code>0x07FF</code></td>
<td><code>110xxxxx</code></td>
<td><code>10xxxxxx</code></td>
<td>—</td>
<td>—</td>
</tr>
<tr class="odd">
<td><code>0x0800</code>–<code>0xFFFF</code></td>
<td><code>1110xxxx</code></td>
<td><code>10xxxxxx</code></td>
<td><code>10xxxxxx</code></td>
<td>—</td>
</tr>
<tr class="even">
<td><code>0x10000</code>–<code>0x10FFFF</code></td>
<td><code>11110xxx</code></td>
<td><code>10xxxxxx</code></td>
<td><code>10xxxxxx</code></td>
<td><code>10xxxxxx</code></td>
</tr>
</tbody>
</table>
</section>
<section id="codifica-utf-16" class="slide level1">
<h1>Codifica UTF-16</h1>
<ul>
<li><p>Funziona come la codifica UTF-8, ma si usano coppie di byte (<span class="math inline">8 + 8 = 16</span>).</p></li>
<li><p>Un <em>code point</em> può essere codificato da due oppure quattro byte.</p></li>
<li><p>C’è anche qui un problema di <em>endianness</em>: il valore <code>0x2A6C</code> si scrive come la coppia di byte <code>0x2A 0x6C</code> (<em>big endian</em>) oppure <code>0x6C 0x2A</code> (<em>little endian</em>)?</p></li>
<li><p>Nei file di testo codificati con UTF-16 si inserisce all’inizio del file il cosiddetto BOM (<em>byte-order marker</em>) che corrisponde al <em>code point</em> <code>0xFEFF</code>. Se i primi due byte di un file sono <code>0xFE 0xFF</code>, allora è chiaro che il file usa <em>big endian</em>, se sono <code>0xFF 0xFE</code> usa <em>little endian</em>. (Anche UTF-8 ha un BOM, <code>0xEF 0xBB 0xBF</code>, che però non è così utile).</p></li>
<li><p>UTF-16 è usato da Windows e nei linguaggi basati su Java (Kotlin, Scala, etc.).</p></li>
</ul>
</section>
<section id="codifica-utf-32" class="slide level1">
<h1>Codifica UTF-32</h1>
<ul>
<li><p>Ovviamente, usa 32 bit per <em>code point</em>.</p></li>
<li><p>In questo caso non c’è ambiguità: ogni code point usa esattamente quattro byte.</p></li>
<li><p>È ovviamente la codifica più inefficiente dal punto di vista dello spazio occupato: la poesia di Emily Dickinson occuperebbe 928 byte in UTF-32, e solo 232 byte in ASCII/UTF-8 (quattro volte tanto!)</p></li>
<li><p>È però la codifica più semplice: ogni code point occupa sempre lo spazio di un tipo <code>uint32_t</code> in C/C++.</p></li>
</ul>
</section>
<section id="file-binari-e-testuali" class="slide level1">
<h1>File binari e testuali</h1>
<ul>
<li><p>Quanto detto oggi spiega perché è spesso più vantaggioso usare <em>file binari</em> anziché testuali: è molto più facile per un programma leggerli e scriverli!</p></li>
<li><p>Quasi tutti i formati grafici oggi usati (PNG, JPEG, GIF, etc.) si basano su codifiche binarie.</p></li>
<li><p>I file testuali hanno però alcuni vantaggi significativi:</p>
<ul>
<li><p>Sono più facili da leggere e da scrivere per un essere umano;</p></li>
<li><p>Non hanno problemi di <em>endianness</em>.</p></li>
</ul></li>
<li><p>Questa settimana e la prossima lavoreremo su file binari; tra alcune settimane passeremo ai file testuali per leggere i file di input del nostro programma.</p></li>
</ul>
</section>
    </div>
  </div>

  <script src="https://unpkg.com/reveal.js@^4//dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="https://unpkg.com/reveal.js@^4//plugin/notes/notes.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/search/search.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/zoom/zoom.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: true,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'bottom-right',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: false,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'default',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'fade',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

       // Parallax background image
       parallaxBackgroundImage: './media/background.png', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1440,

        height: 810,

        // reveal.js plugins
        plugins: [
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script src="js/asciinema-player.js"></script>
    <script src="https://cdn.plot.ly/plotly-1.58.4.min.js"></script>
    <script type="text/javascript" src="./js/quantization.js"></script>
    </body>
</html>
