<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Maurizio Tomasi maurizio.tomasi@unimi.it">
  <title>Lezione 13</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/theme/white.css" id="theme">
  <link rel="stylesheet" href="./css/custom.css"/>
  <link rel="stylesheet" href="./css/asciinema-player.css"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Lezione 13</h1>
  <p class="subtitle">Analisi lessicale</p>
  <p class="author">Maurizio Tomasi <a href="mailto:maurizio.tomasi@unimi.it" class="email">maurizio.tomasi@unimi.it</a></p>
</section>

<section id="interpretare-file-di-testo" class="slide level1">
<h1>Interpretare file di testo</h1>
</section>
<section id="contesto-del-problema" class="slide level1">
<h1>Contesto del problema</h1>
<ul>
<li><p>Finora abbiamo creato immagini fotorealistiche modificando il comando <code>demo</code> del nostro raytracer.</p></li>
<li><p>Dovreste aver ormai riscontrato tutti una certa farraginosità nella procedura! Tutte le volte che abbiamo voluto modificare l’immagine, occorreva compiere queste azioni:</p>
<ol>
<li>Modificare il codice nel <code>main</code>;</li>
<li>Ricompilare;</li>
<li>Eseguire il codice e controllare il risultato.</li>
</ol></li>
<li><p>Questo approccio potrebbe non essere sostenibile: di fatto obblighiamo gli utenti a scrivere codice nel linguaggio di programmazione che abbiamo usato!</p></li>
</ul>
</section>
<section id="file-di-input" class="slide level1">
<h1>File di input</h1>
<ul>
<li><p>Perché il nostro programma sia davvero versatile (e possa meritare il rilascio di una versione <code>1.0.0</code>), deve smettere di produrre solo immagini dimostrative (il comando <code>demo</code>).</p></li>
<li><p>Dovrebbe invece prendere in input una descrizione di una scena e produrre in output l’immagine corrispondente.</p></li>
<li><p>Ma come fa l’utente a fornire in input una descrizione della scena?</p></li>
</ul>
</section>
<section id="categorie-di-utenti" class="slide level1">
<h1>Categorie di utenti</h1>
<ul>
<li><p>Nel caso in cui il linguaggio usato sia Julia o Python, che ammette un uso interattivo, non è affatto strano chiedere che l’utente definisca le scene direttamente dalla REPL (o da un notebook Jupyter/Pluto)!</p></li>
<li><p>Ma nel caso di programmi scritti in C++, C# o Kotlin, una soluzione del genere non è percorribile: non è affatto detto che l’utente abbia installato gli strumenti di sviluppo e le librerie necessarie per modificare e ricompilare il programma.</p></li>
<li><p>Quello che faremo oggi è implementare un nostro mini-linguaggio per la definizione delle scene. <strong>Non è la soluzione migliore</strong> per chi usa Julia, ma chiedo comunque a tutti di implementare quanto richiesto, perché il valore dell’esercizio è soprattutto didattico.</p></li>
</ul>
</section>
<section id="valore-didattico-dellesercizio" class="slide level1">
<h1>Valore didattico dell’esercizio</h1>
<ul>
<li><p>Per implementare questa <em>feature</em> dovremo apprendere i rudimenti della teoria dei compilatori, che non viene affrontata in altri corsi (che io sappia).</p></li>
<li><p>Dovremo scrivere codice che gestisca le (tante) possibili condizioni di errore in modo robusto ed elegante, più di quanto abbiamo fatto sinora (un <em>path-tracer</em> non è il genere di programma indicato per questo!): ciò è molto educativo!</p></li>
<li><p>Capirete meglio il funzionamento (e i messaggi di errore!) dei compilatori, e anche certe caratteristiche dei linguaggi di programmazione che avete usato.</p></li>
<li><p>È intellettualmente stimolante… e può essere anche molto divertente!</p></li>
</ul>
</section>
<section id="tipi-di-linguaggi" class="slide level1">
<h1>Tipi di linguaggi</h1>
<dl>
<dt><em>General-purpose languages</em></dt>
<dd>Questi sono i «linguaggi di programmazione» che avete usato sino ad oggi (C++, Python, etc.). Sono chiamati <em>general-purpose</em> perché non sono pensati per un dominio specifico, potendo essere usati per creare videogiochi, sistemi operativi, librerie numeriche, applicazioni grafiche, etc.
</dd>
<dt><em>Domain-specific languages</em> (DSL)</dt>
<dd>Si tratta di linguaggi che risolvono un problema molto specifico, e la cui sintassi è pensata per esprimere il problema nel modo più naturale possibile.
</dd>
</dl>
</section>
<section id="esempio-di-dsl-sql" class="slide level1">
<h1>Esempio di DSL: SQL</h1>
<ul>
<li><p>SQL (<em>Structured Query Language</em>) è un linguaggio usato per creare/modificare/consultare tabelle di dati salvate in database:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> measurement (<span class="dt">time</span> text, sensor text, <span class="fu">value</span> <span class="dt">real</span>, flags <span class="dt">number</span>);</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">INSERT</span> <span class="kw">INTO</span> measurement <span class="kw">VALUES</span> (<span class="st">&#39;2021-06-06&#39;</span>, <span class="st">&#39;LKS-0001&#39;</span>, <span class="fl">1.73</span>, <span class="dv">0</span>);</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">INSERT</span> <span class="kw">INTO</span> measurement <span class="kw">VALUES</span> (<span class="st">&#39;2021-06-07&#39;</span>, <span class="st">&#39;LKS-0001&#39;</span>, <span class="fl">1.46</span>, <span class="dv">1</span>);</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="dt">time</span>, <span class="fu">value</span> <span class="kw">FROM</span> measurement <span class="kw">WHERE</span> sensor <span class="op">=</span> <span class="st">&#39;LKS-0001&#39;</span> <span class="kw">AND</span> <span class="fu">value</span> <span class="op">&gt;</span> <span class="fl">1.50</span>;</span></code></pre></div></li>
<li><p>La libreria <a href="https://www.sqlite.org/index.html">sqlite3</a> implementa un interprete SQL e un formato di dati, consentendo di salvare/leggere questi database da file. È una delle librerie più usate al mondo, ed è usata in Linux, Mac OS X, Android e iOS.</p></li>
<li><p>È una libreria invocabile da <a href="https://www.sqlite.org/cintro.html">C/C++</a>, <a href="https://docs.python.org/3/library/sqlite3.html">Python</a>, <a href="https://zetcode.com/csharp/sqlite/">C#</a>, etc., ma il comando consente di operare direttamente dalla linea di comando!</p></li>
</ul>
</section>
<section class="slide level1">

<p><asciinema-player src="cast/sqlite3-example-89x25.cast" cols="89" rows="25" font-size="medium"></asciinema-player></p>
<p>Immaginate come implementare questi comandi in linguaggi come C++ o Python. Ovviamente SQL è molto più immediato!</p>
</section>
<section id="dsl-in-linguaggi-general-purpose" class="slide level1">
<h1>DSL in linguaggi <em>general-purpose</em></h1>
<ul>
<li><p>Alcuni linguaggi <em>general-purpose</em> sono <em>metaprogrammabili</em>, ossia hanno la capacità di estendere la propria sintassi.</p></li>
<li><p>Questa capacità consente di definire delle DSL all’interno del linguaggio stesso (es., <a href="https://gigamonkeys.com/book/practical-a-simple-database.html">Common LISP</a>, <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/">Julia</a>, <a href="https://www.raywenderlich.com/2780058-domain-specific-languages-in-kotlin-getting-started">Kotlin</a>, <a href="https://forum.nim-lang.org/t/2380">Nim</a>…).</p></li>
<li><p>Vediamo un paio di esempi.</p></li>
</ul>
</section>
<section id="esempio-di-dsl-acme.jl" class="slide level1">
<h1>Esempio di DSL: <a href="https://github.com/HSU-ANT/ACME.jl">ACME.jl</a></h1>
<div class="sourceCode" id="cb2"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> ACME</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>circ <span class="op">=</span> <span class="pp">@circuit</span> <span class="kw">begin</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    j_in <span class="op">=</span> voltagesource()</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    r1 <span class="op">=</span> resistor(<span class="fl">1e3</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    c1 <span class="op">=</span> capacitor(<span class="fl">47e-9</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    d1 <span class="op">=</span> diode(is<span class="op">=</span><span class="fl">1e-15</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    d2 <span class="op">=</span> diode(is<span class="op">=</span><span class="fl">1.8e-15</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    j_out <span class="op">=</span> voltageprobe()</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    j_in[<span class="op">+</span>] ⟷ r1[<span class="fl">1</span>]</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    j_in[<span class="op">-</span>] ⟷ gnd</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    r1[<span class="fl">2</span>] ⟷ c1[<span class="fl">1</span>] ⟷ d1[<span class="op">+</span>] ⟷ d2[<span class="op">-</span>] ⟷ j_out[<span class="op">+</span>]</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    gnd ⟷ c1[<span class="fl">2</span>] ⟷ d1[<span class="op">-</span>] ⟷ d2[<span class="op">+</span>] ⟷ j_out[<span class="op">-</span>]</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>La libreria ACME definisce una serie di operatori come <code>⟷</code> e <code>[±]</code> che consentono di descrivere un circuito elettrico con una sintassi immediatamente comprensibile.</p>
</section>
<section id="esempio-di-dsl-karax" class="slide level1">
<h1>Esempio di DSL: <a href="https://github.com/karaxnim/karax">Karax</a></h1>
<div class="sourceCode" id="cb3"><pre class="sourceCode nim"><code class="sourceCode nim"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> karax <span class="co">/</span> <span class="kw">[</span>karaxdsl<span class="kw">,</span> vdom<span class="kw">]</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> places <span class="co">=</span> <span class="co">@</span><span class="kw">[</span><span class="st">&quot;boston&quot;</span><span class="kw">,</span> <span class="st">&quot;cleveland&quot;</span><span class="kw">,</span> <span class="st">&quot;los angeles&quot;</span><span class="kw">,</span> <span class="st">&quot;new orleans&quot;</span><span class="kw">]</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">proc</span> <span class="st">render</span><span class="co">*</span><span class="kw">():</span> <span class="at">string</span> <span class="co">=</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> vnode <span class="co">=</span> <span class="fu">buildHtml</span><span class="kw">(</span><span class="fu">tdiv</span><span class="kw">(</span>class <span class="co">=</span> <span class="st">&quot;mt-3&quot;</span><span class="kw">)):</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    h1<span class="kw">:</span> <span class="fu">text</span> <span class="st">&quot;My Web Page&quot;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    p<span class="kw">:</span> <span class="fu">text</span> <span class="st">&quot;Hello world&quot;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    ul<span class="kw">:</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> place <span class="co">in</span> places<span class="kw">:</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        li<span class="kw">:</span> <span class="fu">text</span> place</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    dl<span class="kw">:</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>      dt<span class="kw">:</span> <span class="fu">text</span> <span class="st">&quot;Can I use Karax for client side single page apps?&quot;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>      dd<span class="kw">:</span> <span class="fu">text</span> <span class="st">&quot;Yes&quot;</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>      dt<span class="kw">:</span> <span class="fu">text</span> <span class="st">&quot;Can I use Karax for server side HTML rendering?&quot;</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>      dd<span class="kw">:</span> <span class="fu">text</span> <span class="st">&quot;Yes&quot;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>  <span class="ot">result</span> <span class="co">=</span> <span class="co">$</span>vnode</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="cf">echo</span> <span class="fu">render</span><span class="kw">()</span></span></code></pre></div>
<p>La libreria <a href="https://github.com/karaxnim/karax">karax/karaxdsl</a> estende il linguaggio <a href="https://nim-lang.org/">Nim</a> con comandi come <code>h1</code> e <code>p</code>, in modo che si possano definire gli elementi che definiscono una pagina HTML.</p>
</section>
<section id="linguaggi-per-la-definizione-di-scene-3d" class="slide level1">
<h1>Linguaggi per la definizione di scene 3D</h1>
</section>
<section id="dkbtrace" class="slide level1">
<h1>DKBTrace</h1>
<ul>
<li>Nel 1986 David K. Buck rilasciò DKBTrace, un ray-tracer che usava l’algoritmo di <em>point-light tracing</em>.</li>
<li>Scritto in C.</li>
<li>Il programma funzionava solo sul <a href="https://en.wikipedia.org/wiki/Amiga">Commodore Amiga</a>, un vecchio microcomputer molto usato all’epoca per la grafica.</li>
<li>Lo sviluppatore abbandonò ben presto DKBTrace per lavorare a POV-Ray (che vedremo tra poco).</li>
</ul>
</section>
<section id="file-di-input-1" class="slide level1">
<h1>File di input</h1>
<pre class="text"><code>{ DKBTrace example file }
INCLUDE &quot;colors.dat&quot;
INCLUDE &quot;shapes.dat&quot;
INCLUDE &quot;textures.dat&quot;

VIEW_POINT
    LOCATION  &lt;0 0 0&gt;
    DIRECTION &lt;0 0 1&gt;
    UP        &lt;0 1 0&gt;
    RIGHT     &lt;1.33333 0 0&gt;
END_VIEW_POINT

OBJECT
    SPHERE
        &lt;0 0 3&gt; 1
    END_SPHERE
    TEXTURE
        COLOUR Red
    END_TEXTURE
END_OBJECT

OBJECT
    SPHERE
        &lt;0 0 0&gt; 1
    END_SPHERE
    TEXTURE
        COLOUR White
    END_TEXTURE
    TRANSLATE &lt;2 4 -3&gt;
    LIGHT_SOURCE
    COLOUR White
END_OBJECT</code></pre>
</section>
<section id="pov-ray" class="slide level1">
<h1><a href="http://povray.org/">POV-Ray</a></h1>
<ul>
<li><p>POV-Ray risolve l’equazione del rendering usando il <em>point-light tracing</em> (ma che nel manuale di POV-Ray viene chiamato semplicemente <em>raytracing</em>), esattamente come DKBTrace.</p></li>
<li><p>La prima versione è stata rilasciata nel 1991; al momento la versione più recente è la 3.7.0 (rilasciata nel 2013). La versione 3.8 è in fase di preparazione.</p></li>
<li><p>In origine era stato scritto in C, e poi <a href="https://github.com/POV-Ray/povray/tree/3.7-stable">riscritto in C++</a>.</p></li>
<li><p>A partire dalla versione 3.0 implementa l’algoritmo <a href="https://en.wikipedia.org/wiki/Radiosity_(computer_graphics)"><em>radiosity</em></a> per simulare sorgenti diffuse in maniera simile al path-tracing.</p></li>
</ul>
</section>
<section class="slide level1">

<center>
<img data-src="media/mtpiano.webp" height="640" />
</center>
</section>
<section id="file-di-input-2" class="slide level1">
<h1>File di input</h1>
<div class="sourceCode" id="cb5"><pre class="sourceCode povray"><code class="sourceCode povray"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">// POV-Ray example file</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ot">#include</span> <span class="st">&quot;colors.inc&quot;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="va">background</span> <span class="op">{</span> <span class="at">color</span> Cyan <span class="op">}</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#declare </span><span class="fu">tex </span><span class="op">=</span> <span class="at">texture</span> <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">pigment</span> <span class="op">{</span> <span class="at">color</span> Yellow <span class="op">}</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="va">camera</span> <span class="op">{</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  <span class="va">location</span> <span class="op">&lt;</span><span class="fl">0</span><span class="op">,</span> <span class="fl">2</span><span class="op">,</span> <span class="op">-</span><span class="fl">3</span><span class="op">&gt;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  <span class="va">look_at</span>  <span class="op">&lt;</span><span class="fl">0</span><span class="op">,</span> <span class="fl">1</span><span class="op">,</span>  <span class="fl">2</span><span class="op">&gt;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="wa">sphere</span> <span class="op">{</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;</span><span class="fl">0</span><span class="op">,</span> <span class="fl">1</span><span class="op">,</span> <span class="fl">2</span><span class="op">&gt;,</span> <span class="fl">2</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>  <span class="at">texture</span> <span class="op">{</span> tex <span class="op">}</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="wa">light_source</span> <span class="op">{</span> <span class="op">&lt;</span><span class="fl">2</span><span class="op">,</span> <span class="fl">4</span><span class="op">,</span> <span class="op">-</span><span class="fl">3</span><span class="op">&gt;</span> <span class="at">color</span> White <span class="op">}</span></span></code></pre></div>
</section>
<section id="polyray" class="slide level1">
<h1>PolyRay</h1>
<ul>
<li>Creato da Alexander Enzmann nel 1991 (lo stesso anno di POV-Ray!).</li>
<li>Scritto interamente in C.</li>
<li>Ultima versione (1.8) rilasciata nel 1995.</li>
<li>Non più sviluppato, ma usato come ispirazione nello sviluppo delle versioni di POV-Ray successive alla 1.0.</li>
</ul>
</section>
<section id="file-di-input-3" class="slide level1">
<h1>File di input</h1>
<pre class="text"><code>// PolyRay example file
viewpoint {
    from &lt;0,0,-8&gt;        // The location of the eye
    at &lt;0,0,0&gt;           // The point that we are looking at
    up &lt;0,1,0&gt;           // The direction that will be up
    angle 45             // The vertical field of view
    resolution 160, 160  // The image will be 160x160 pixels
}

background skyblue

light &lt;-10,3, -20&gt;

define shiny_red
texture {
   surface {
      color red
      ambient 0.2
      diffuse 0.6
      specular white, 0.5
      microfacet Cook 5
   }
}

object {
   sphere &lt;0, 0, 0&gt;, 2
   shiny_red
}</code></pre>
</section>
<section id="yafaray" class="slide level1">
<h1><a href="http://www.yafaray.org/">YafaRay</a></h1>
<ul>
<li><p>Scritto in C++ (repository su <a href="https://github.com/YafaRay">GitHub</a>).</p></li>
<li><p>Risolve l’equazione del rendering usando un algoritmo di <em>path-tracing</em>.</p></li>
<li><p>Può essere usato in Blender come «motore» per il rendering.</p></li>
<li><p>Il formato delle scene è XML.</p></li>
</ul>
</section>
<section class="slide level1">

<center>
<img data-src="media/yafray-example.webp" />
</center>
</section>
<section id="file-di-input-4" class="slide level1">
<h1>File di input</h1>
<div class="sourceCode" id="cb7"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;scene&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;shader</span><span class="ot"> type=</span><span class="st">&quot;generic&quot;</span><span class="ot"> name=</span><span class="st">&quot;Default&quot;</span><span class="kw">&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;attributes&gt;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">&lt;color</span><span class="ot"> r=</span><span class="st">&quot;0.750000&quot;</span><span class="ot"> g=</span><span class="st">&quot;0.750000&quot;</span><span class="ot"> b=</span><span class="st">&quot;0.800000&quot;</span> <span class="kw">/&gt;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">&lt;specular</span><span class="ot"> r=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> g=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> b=</span><span class="st">&quot;0.000000&quot;</span> <span class="kw">/&gt;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">&lt;reflected</span><span class="ot"> r=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> g=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> b=</span><span class="st">&quot;0.000000&quot;</span> <span class="kw">/&gt;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">&lt;transmitted</span><span class="ot"> r=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> g=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> b=</span><span class="st">&quot;0.000000&quot;</span> <span class="kw">/&gt;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;/attributes&gt;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/shader&gt;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;transform</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    m00=</span><span class="st">&quot;8.532125&quot;</span><span class="ot"> m01=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> m02=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> m03=</span><span class="st">&quot;0.000000&quot;</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="ot">    m10=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> m11=</span><span class="st">&quot;8.532125&quot;</span><span class="ot"> m12=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> m13=</span><span class="st">&quot;0.000000&quot;</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="ot">    m20=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> m21=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> m22=</span><span class="st">&quot;8.532125&quot;</span><span class="ot"> m23=</span><span class="st">&quot;0.000000&quot;</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="ot">    m30=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> m31=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> m32=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> m33=</span><span class="st">&quot;1.000000&quot;</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="kw">&gt;</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;object</span><span class="ot"> name=</span><span class="st">&quot;Plane&quot;</span><span class="ot"> shader_name=</span><span class="st">&quot;Default&quot;</span> <span class="kw">&gt;</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;attributes&gt;</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;/attributes&gt;</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;mesh&gt;</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">&lt;include</span><span class="ot"> file=</span><span class="st">&quot;.\Meshes\Plane.xml&quot;</span> <span class="kw">/&gt;</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;/mesh&gt;</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/object&gt;</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/transform&gt;</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;light</span><span class="ot"> type=</span><span class="st">&quot;pathlight&quot;</span><span class="ot"> name=</span><span class="st">&quot;path&quot;</span><span class="ot"> power=</span> <span class="st">&quot;1.000000&quot;</span><span class="ot"> depth=</span><span class="st">&quot;2&quot;</span><span class="ot"> samples=</span><span class="st">&quot;16&quot;</span> </span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a><span class="ot">       use_QMC=</span><span class="st">&quot;on&quot;</span><span class="ot"> cache=</span><span class="st">&quot;on&quot;</span><span class="ot">  cache_size=</span><span class="st">&quot;0.008000&quot;</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a><span class="ot">       angle_threshold=</span><span class="st">&quot;0.200000&quot;</span><span class="ot">  shadow_threshold=</span><span class="st">&quot;0.200000&quot;</span> <span class="kw">&gt;</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/light&gt;</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;camera</span><span class="ot"> name=</span><span class="st">&quot;Camera&quot;</span><span class="ot"> resx=</span><span class="st">&quot;1024&quot;</span><span class="ot"> resy=</span><span class="st">&quot;576&quot;</span><span class="ot"> focal=</span><span class="st">&quot;1.015937&quot;</span> <span class="kw">&gt;</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;from</span><span class="ot"> x=</span><span class="st">&quot;0.323759&quot;</span><span class="ot"> y=</span><span class="st">&quot;-7.701275&quot;</span><span class="ot"> z=</span><span class="st">&quot;2.818493&quot;</span> <span class="kw">/&gt;</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;to</span><span class="ot"> x=</span><span class="st">&quot;0.318982&quot;</span><span class="ot"> y=</span><span class="st">&quot;-6.717273&quot;</span><span class="ot"> z=</span><span class="st">&quot;2.640400&quot;</span> <span class="kw">/&gt;</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;up</span><span class="ot"> x=</span><span class="st">&quot;0.323330&quot;</span><span class="ot"> y=</span><span class="st">&quot;-7.523182&quot;</span><span class="ot"> z=</span><span class="st">&quot;3.802506&quot;</span> <span class="kw">/&gt;</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/camera&gt;</span></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;filter</span><span class="ot"> type=</span><span class="st">&quot;dof&quot;</span><span class="ot"> name=</span><span class="st">&quot;dof&quot;</span><span class="ot"> focus=</span><span class="st">&quot;7.97854234329&quot;</span><span class="ot"> near_blur=</span><span class="st">&quot;10.000000&quot;</span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a><span class="ot">        far_blur=</span><span class="st">&quot;10.000000&quot;</span><span class="ot"> scale=</span><span class="st">&quot;2.000000&quot;</span><span class="kw">&gt;</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/filter&gt;</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;filter</span><span class="ot"> type=</span><span class="st">&quot;antinoise&quot;</span><span class="ot"> name=</span><span class="st">&quot;Anti Noise&quot;</span><span class="ot"> radius=</span><span class="st">&quot;1.000000&quot;</span></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a><span class="ot">        max_delta=</span><span class="st">&quot;0.100000&quot;</span><span class="kw">&gt;</span></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/filter&gt;</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;background</span><span class="ot"> type=</span><span class="st">&quot;HDRI&quot;</span><span class="ot"> name=</span><span class="st">&quot;envhdri&quot;</span><span class="ot"> exposure_adjust=</span><span class="st">&quot;1&quot;</span><span class="kw">&gt;</span></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;filename</span><span class="ot"> value=</span><span class="st">&quot;Filename.HDR&quot;</span> <span class="kw">/&gt;</span></span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/background&gt;</span></span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;render</span><span class="ot"> camera_name=</span><span class="st">&quot;Camera&quot;</span><span class="ot"> AA_passes=</span><span class="st">&quot;2&quot;</span><span class="ot"> AA_minsamples=</span><span class="st">&quot;2&quot;</span></span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a><span class="ot">        AA_pixelwidth=</span><span class="st">&quot;1.500000&quot;</span><span class="ot"> AA_threshold=</span><span class="st">&quot;0.040000&quot;</span></span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a><span class="ot">        raydepth=</span><span class="st">&quot;5&quot;</span><span class="ot"> bias=</span><span class="st">&quot;0.300000&quot;</span><span class="ot"> indirect_samples=</span><span class="st">&quot;1&quot;</span></span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a><span class="ot">        gamma=</span><span class="st">&quot;1.000000&quot;</span><span class="ot"> exposure=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> background_name=</span><span class="st">&quot;envhdri&quot;</span><span class="kw">&gt;</span></span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;outfile</span><span class="ot"> value=</span><span class="st">&quot;butterfly2.tga&quot;</span><span class="kw">/&gt;</span></span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;save_alpha</span><span class="ot"> value=</span><span class="st">&quot;on&quot;</span><span class="kw">/&gt;</span></span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/render&gt;</span></span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/scene&gt;</span></span></code></pre></div>
</section>
<section id="il-nostro-formato" class="slide level1">
<h1>Il «nostro» formato</h1>
</section>
<section id="obbiettivo" class="slide level1">
<h1>Obbiettivo</h1>
<ul>
<li><p>Il nostro obbiettivo è di definire un <em>formato</em> per la descrizione delle scene, e di scrivere del codice per interpretarlo.</p></li>
<li><p>Una volta implementato, l’utente userà un comune editor come Emacs o Visual Studio Code per creare un file, chiamato ad es. <code>scene.txt</code>, ed eseguirà il programma così:</p>
<pre><code>./myprogram render scene.txt</code></pre>
<p>e gli oggetti <code>Shape</code> e <code>Material</code> saranno creati in memoria basandosi su quanto specificato in <code>scene.txt</code>. Il rendering poi procederà esattamente come il comando <code>demo</code>, con la differenza che ora l’utente potrà modificare facilmente <code>scene.txt</code>.</p></li>
</ul>
</section>
<section id="definire-il-formato" class="slide level1">
<h1>Definire il formato</h1>
<ul>
<li><p>Ci aspetta ora un compito molto eccitante: definire come strutturare il nostro formato!</p></li>
<li><p>Potremmo accontentarci di un formato molto semplice, come il Wavefront OBJ che avevamo descritto <a href="./tomasi-ray-tracing-10a-other-shapes.html#wavefront-obj">tempo fa</a>.</p></li>
<li><p>Ad esempio, potremmo definire una BRDF diffusiva (<code>d</code>) con colore <span class="math inline">(0.3, 0.7, 0.5)</span> associata a una sfera (<code>s</code>) centrata in <span class="math inline">(1, 3, 6)</span> di raggio <span class="math inline">r = 2</span> così:</p>
<pre class="text"><code>d 0.3 0.7 0.5
s 1 3 6 2</code></pre>
<p>Ma non sarebbe affatto leggibile! Proviamo a pensare a qualcosa di più strutturato.</p></li>
</ul>
</section>
<section id="come-implementare-il-formato" class="slide level1">
<h1>Come implementare il formato</h1>
<ul>
<li><p>Ovviamente il formato non deve essere ambiguo, e deve essere facile da ricordare.</p></li>
<li><p>Anziché usare lettere come <code>s</code> o <code>d</code> per indicare diverse entità (sfera o BRDF diffusiva), useremo stringhe di caratteri (<code>sphere</code> e <code>diffuse</code>)</p></li>
<li><p>La scrittura <code>s 1 3 6 2</code> non è chiara, perché non si distingue il raggio dalle coordinate. Ispirandoci alla sintassi POV-Ray, indicheremo punti e vettori con le parentesi angolari, ad es. <code>&lt;1, 3, 6&gt;</code>.</p></li>
<li><p>Implementeremo anche la possibilità di associare un nome agli oggetti: in questo modo potremo fare riferimento a BRDF create in precedenza (es., <code>green_matte</code>) quando definiamo nuove <code>Shape</code>.</p></li>
</ul>
</section>
<section id="cosa-includere" class="slide level1">
<h1>Cosa includere</h1>
<p>Pensiamo a cosa deve essere specificabile nel nostro formato. Dobbiamo sicuramente prevedere una sintassi per ciascuno di questi oggetti:</p>
<ul>
<li>Osservatori;</li>
<li>Forme (sfere, piani, e qualsiasi altro oggetto voi abbiate implementato);</li>
<li>Trasformazioni;</li>
<li>Vettori;</li>
<li>Materiali;</li>
<li>BRDF;</li>
<li>Pigmenti;</li>
<li>Colori;</li>
<li>Numeri.</li>
</ul>
</section>
<section id="scelte-da-compiere" class="slide level1">
<h1>Scelte da compiere</h1>
<ul>
<li><p>Dobbiamo definire una sintassi per creare oggetti, e ovviamente ci sono varie possibilità. Ad esempio, per definire una sfera potremmo usare una qualsiasi di queste forme:</p>
<pre class="text"><code>sphere: &lt;1, 3, 6&gt;, 2
sphere(&lt;1, 3, 6&gt;, 2)
sphere with center=&lt;1, 3, 6&gt;, radius=2
&lt;1, 3, 6&gt; 2 sphere</code></pre>
<p>(L’ultima sintassi è comune in linguaggi <em>stack-based</em> come il Postscript).</p></li>
<li><p>La scelta dell’una o dell’altra sintassi è in linea di principio completamente nelle nostre mani!</p></li>
<li><p>Senza ulteriori indugi, vi mostro la sintassi che ho scelto per il corso tramite un esempio concreto.</p></li>
</ul>
</section>
<section id="esempio-di-formato" class="slide level1">
<h1>Esempio di formato</h1>
<div class="sourceCode" id="cb11"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Declare a floating-point variable named &quot;clock&quot;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ex">float</span> clock(150)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Declare a few new materials. Each of them includes a BRDF and a pigment</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co"># We can split a definition over multiple lines and indent them as we like</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="ex">material</span> sky_material(</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="ex">diffuse</span>(image(<span class="st">&quot;sky-dome.pfm&quot;</span>)),</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="ex">uniform</span>(<span class="op">&lt;</span>0.7, 0.5, <span class="op">1&gt;</span>)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="ex">material</span> ground_material(</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="ex">diffuse</span>(checkered(<span class="op">&lt;</span>0.3, 0.5, 0.<span class="op">1&gt;</span>,</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>                      <span class="op">&lt;</span><span class="ex">0.1</span>, 0.2, 0.<span class="op">5&gt;</span>, 4)),</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="ex">uniform</span>(<span class="op">&lt;</span>0, 0, <span class="op">0&gt;</span>)</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="ex">material</span> sphere_material(</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    <span class="ex">specular</span>(uniform(<span class="op">&lt;</span>0.5, 0.5, 0.<span class="op">5&gt;</span>)),</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    <span class="ex">uniform</span>(<span class="op">&lt;</span>0, 0, <span class="op">0&gt;</span>)</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Define a few shapes. Note that we can compose transformations through</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a><span class="co"># the &quot;*&quot; operator</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Here we use the &quot;clock&quot; variable! Note that vectors are notated using</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a><span class="co"># square brackets ([]) instead of angular brackets (&lt;&gt;) like colors</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a><span class="ex">plane</span>(sky_material, translation([0, 0, 100]) <span class="ex">*</span> rotation_y(clock))</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a><span class="co"># The language is flexible enough to permit spaces before &quot;(&quot;</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a><span class="ex">plane</span> (ground_material, identity)</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a><span class="ex">sphere</span>(sphere_material, translation([0, 0, 1]))</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Define a camera</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a><span class="ex">camera</span>(perspective, rotation_z(30) <span class="ex">*</span> translation([-4, 0, 1]), <span class="ex">1.0</span>, 1.0)</span></code></pre></div>
</section>
<section id="come-interpretare-il-formato" class="slide level1">
<h1>Come interpretare il formato?</h1>
<ul>
<li><p>Da un punto di vista puramente concettuale, il compito che ci aspetta non è poi così diverso da quello di leggere un file PFM…</p></li>
<li><p>…con la differenza però che il file di input che consideriamo ora è molto più complesso e «duttile» del formato PFM!</p></li>
<li><p>Questa maggiore versatilità comporta molti più rischi di errore: è facile dimenticarsi una virgola, o confondere un <code>&lt;</code> con un <code>[</code>. Dobbiamo quindi prestare grande cura alla segnalazione degli errori!</p></li>
<li><p>Per interpretare questo tipo di file occorre procedere per gradi.</p></li>
</ul>
</section>
<section id="paragone-coi-compilatori" class="slide level1">
<h1>Paragone coi compilatori</h1>
<ul>
<li><p>Il lavoro che ci aspetta è simile alla scrittura di un compilatore vero e proprio. Ad esempio, il comando <code>g++</code> legge in input file di testo fatti come il seguente:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="at">const</span> <span class="dt">char</span> *argv[]) {</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;The name of the program is &quot;</span> &lt;&lt; argv[<span class="dv">0</span>] &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>e produce in output un file eseguibile che contiene la sequenza di istruzioni macchina corrispondenti a questo codice C++.</p></li>
<li><p>Nel nostro caso il codice deve costruire in memoria una serie di variabili che contengono le <code>Shape</code>, la <code>Camera</code> e i <code>Material</code> di cui è composta la scena.</p></li>
</ul>
</section>
<section id="terminologia" class="slide level1">
<h1>Terminologia</h1>
<p>Per chi lavora con interpreti/compilatori è prassi usare alcuni termini della linguistica:</p>
<ul>
<li>L’analisi del <strong>lessico</strong> studia la tipologia delle singole parole, e stabilisce ad esempio che la parola «invece» è corretta, mentre «invecie» è sbagliata.</li>
<li>L’analisi della <strong>sintassi</strong> studia i rapporti tra gli elementi di una espressione, e stabilisce ad esempio che un verbo non può mai seguire un articolo («un mangeremmo»).</li>
<li>L’analisi della <strong>semantica</strong> studia il rapporto tra una espressione come «la casa in fondo alla strada» e l’oggetto extra-linguistico a cui si fa riferimento (appunto, quella particolare casa in fondo alla strada).</li>
</ul>
</section>
<section id="linguaggi-informatici" class="slide level1">
<h1>Linguaggi informatici</h1>
<p>Nel caso di un «linguaggio» informatico come il nostro, la sua analisi viene solitamente fatta seguendo lo stesso ordine della slide precedente:</p>
<ol type="1">
<li>Un’analisi <strong>lessicale</strong>, in cui si verifica che le singole «parole» siano scritte correttamente;</li>
<li>Un’analisi <strong>sintattica</strong>, in cui si considera come le singole «parole» sono concatenate;</li>
<li>Un’analisi <strong>semantica</strong>, il cui risultato è l’insieme di variabili in memoria del tipo corrispondente (nel nostro caso, <code>Sphere</code>, <code>Plane</code>, <code>SpecularBRDF</code>, etc.), come se fossero state dichiarate ed inizializzate direttamente nel nostro codice sorgente.</li>
</ol>
</section>
<section id="workflow-di-un-compilatore" class="slide level1">
<h1>Workflow di un compilatore</h1>
<p><img data-src="pd-images/compiler-architecture.svg" /></p>
<ul>
<li>Il <em>lexer</em> scompone il sorgente passato come input in elementi semplici, chiamati <em>token</em>;</li>
<li>Il <em>parser</em> analizza la sequenza dei <em>token</em> per legarli tra loro e comprenderne la sintassi e la semantica;</li>
<li>L’<em>AST builder</em> crea il cosiddetto <em>Abstract Syntax Tree</em> (non usato nel nostro caso);</li>
<li>L’<em>optimizer</em> applica ottimizzazioni all’AST (non usato nel nostro caso);</li>
<li>Dall’AST viene generato l’eseguibile (non usato nel nostro caso).</li>
</ul>
</section>
<section id="esempio-analisi-lessicale" class="slide level1">
<h1>Esempio: analisi lessicale</h1>
<ul>
<li><p>Consideriamo le prime righe dell’esempio mostrato poco fa:</p>
<pre class="text"><code># Declare a variable named &quot;clock&quot;
float clock(150)</code></pre></li>
<li><p>Il risultato dell’analisi lessicale delle linee sopra è la produzione della sequenza</p>
<pre class="text"><code>TOKEN_KEYWORD &quot;float&quot;
TOKEN_IDENTIFIER &quot;clock&quot;
TOKEN_SYMBOL &quot;(&quot;
TOKEN_NUMBER 150.0
TOKEN_SYMBOL &quot;)&quot;</code></pre></li>
<li><p>Se l’utente avesse usato una <code>@</code> anziché dello zero nel numero <code>150</code> (scrivendo <code>15@</code>), l’errore sarebbe stato segnalato in questa fase (<em>errore lessicale</em>).</p></li>
<li><p>Il commento nella prima riga non compare nella lista dei token: commenti e spazi bianchi sono di solito rimossi già durante l’analisi lessicale.</p></li>
</ul>
</section>
<section id="esempio-analisi-sintattica" class="slide level1">
<h1>Esempio: analisi sintattica</h1>
<pre class="text"><code># Declare a variable named &quot;clock&quot;
float clock(150)</code></pre>
<ul>
<li><p>L’analisi sintattica parte dalla sequenza di token prodotta dall’analisi lessicale:</p>
<pre class="text"><code>TOKEN_KEYWORD &quot;float&quot;
TOKEN_IDENTIFIER &quot;clock&quot;
TOKEN_SYMBOL &quot;(&quot;
TOKEN_NUMBER 150.0
TOKEN_SYMBOL &quot;)&quot;</code></pre></li>
<li><p>L’analisi sintattica deve verificare che la sequenza di token sia corretta: se il primo token è la parola chiave (<em>keyword</em>) <code>float</code>, allora significa che stiamo definendo una variabile floating-point. È quindi necessario che il token successivo contenga il nome della variabile (deve essere un <em>identificatore</em>), seguito dal valore numerico racchiuso tra le parentesi.</p></li>
</ul>
</section>
<section id="errori-di-sintassi" class="slide level1">
<h1>Errori di sintassi</h1>
<ul>
<li><p>Prendendo spunto da questo esempio, considerate il seguente codice C++:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="cf">if</span>;</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Enter a number: &quot;</span>;</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cin &gt;&gt; <span class="cf">if</span>;</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="cf">if</span> % <span class="dv">2</span> == <span class="dv">0</span>)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;The number is even</span><span class="sc">\n</span><span class="st">&quot;</span>;</span></code></pre></div></li>
<li><p>Questo codice è sbagliato, perché la sintassi del C++ richiede che il tipo della variabile (<code>int</code>) sia seguito da un <em>identificatore</em>, e non da una <em>keyword</em> (<code>if</code>).</p></li>
<li><p>Notate però che il codice sopra è comprensibile da un essere umano! (In LISP il codice sarebbe ok).</p></li>
</ul>
</section>
<section id="esempio-analisi-semantica" class="slide level1">
<h1>Esempio: analisi semantica</h1>
<pre class="text"><code># Declare a variable named &quot;clock&quot;
float clock(150)</code></pre>
<ul>
<li><p>Il risultato dell’analisi sintattica dice che l’istruzione richiede di creare una variabile <code>clock</code> e di assegnarle il valore <code>150.0</code>.</p></li>
<li><p>L’analisi semantica deve verificare che la definizione di questa variabile non crei inconsistenze. Ad esempio, potrebbe verificare che <code>clock</code> non fosse già stata definita in precedenza, e nel caso scegliere una di queste possibilità:</p>
<ol type="1">
<li>Produrre un errore (è il caso del C++);</li>
<li>Aggiornare il valore della variabile <code>clock</code> anziché definirne una nuova con lo stesso nome (è il caso del Python e di Scheme).</li>
</ol></li>
</ul>
</section>
<section id="implementazione" class="slide level1">
<h1>Implementazione</h1>
</section>
<section id="funzionamento-del-lexer" class="slide level1">
<h1>Funzionamento del <em>lexer</em></h1>
<ul>
<li><p>Il <em>lexer</em> è la parte di codice che si occupa dell’analisi lessicale.</p></li>
<li><p>Il suo compito è di leggere da uno <em>stream</em> (tipicamente un file) e produrre in output una lista di <em>token</em>, classificati secondo il loro tipo.</p></li>
<li><p>Per motivi di efficienza, i lexer <em>non</em> restituiscono una lista di token, ma leggono i <em>token</em> uno alla volta, restituendoli man mano che li interpretano, e si usano quindi così:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    token <span class="op">=</span> read_token()</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> token.eof():</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    …</span></code></pre></div></li>
</ul>
</section>
<section id="output-di-un-lexer" class="slide level1">
<h1>Output di un <em>lexer</em></h1>
<ul>
<li><p>Un <em>lexer</em> deve restituire un <em>token</em> della tipologia «giusta».</p></li>
<li><p>A seconda del linguaggio esistono vari tipi di token; nel nostro caso abbiamo:</p>
<ol>
<li><em>Keyword</em>: una parola chiave del linguaggio, come <code>sphere</code> e <code>diffuse</code>;</li>
<li><em>Identifier</em>: il nome di una variabile/tipo/funzione come <code>clock</code>;</li>
<li><em>Numeric literal</em>: un numero come <code>150</code>, possibilmente distinto tra <em>integer literal</em> e <em>floating-point literal</em>;</li>
<li><em>String literal</em>: una stringa di caratteri, solitamente racchiusa tra <code>"</code> (doppi apici) o <code>'</code> (singoli apici);</li>
<li><em>Symbol</em>: un carattere non alfanumerico, come <code>(</code>, <code>+</code>, <code>,</code>, etc.) Non considereremo simboli composti da più caratteri (es., <code>&gt;=</code> in C++).</li>
</ol></li>
</ul>
</section>
<section id="tipi-di-token" class="slide level1">
<h1>Tipi di <em>token</em></h1>
<ul>
<li><p>L’implementazione del tipo <code>Token</code> ci consente di approfondire il sistema dei tipi dei linguaggi che abbiamo usato nel corso.</p></li>
<li><p>Concettualmente, i diversi tipi di <em>token</em> sono derivati da un tipo base, <code>Token</code> appunto. È quindi naturale pensare a una gerarchia di classi, che ha <code>Token</code> come tipo base.</p></li>
<li><p>Questa soluzione funziona, ed è ciò che ho usato in pytracer. Non è però la soluzione più comoda!</p></li>
</ul>
</section>
<section class="slide level1">

<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Token:</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;A lexical token, used when parsing a scene file&quot;&quot;&quot;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    file_name: <span class="bu">str</span> <span class="op">=</span> <span class="st">&quot;&quot;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    line_num: <span class="bu">int</span> <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    col_num: <span class="bu">int</span> <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> LiteralNumberToken(Token):</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;A token containing a literal number&quot;&quot;&quot;</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, file_name: <span class="bu">str</span>, line_num: <span class="bu">int</span>, col_num: <span class="bu">int</span>, value: <span class="bu">float</span>):</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(file_name<span class="op">=</span>file_name, line_num<span class="op">=</span>line_num, col_num<span class="op">=</span>col_num)</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.value <span class="op">=</span> value</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">str</span>(<span class="va">self</span>.value)</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SymbolToken(Token):</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;A token containing a symbol (i.e., a variable name)&quot;&quot;&quot;</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, file_name: <span class="bu">str</span>, line_num: <span class="bu">int</span>, col_num: <span class="bu">int</span>, symbol: <span class="bu">str</span>):</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(file_name<span class="op">=</span>file_name, line_num<span class="op">=</span>line_num, col_num<span class="op">=</span>col_num)</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.symbol <span class="op">=</span> symbol</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.symbol</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Etc.</span></span></code></pre></div>
</section>
<section id="tokens-e-gerarchie-di-classi" class="slide level1">
<h1><em>Tokens</em> e gerarchie di classi</h1>
<ul>
<li><p>Ci sono alcuni svantaggi nell’usare una gerarchia di classi:</p>
<ol>
<li>Il codice diventa molto verboso: si devono implementare tante classi, tutte molto simili tra loro.</li>
<li>Le gerarchie di classi sono pensate per essere <em>estendibili</em>: posso sempre definire una nuova classe derivata da <code>Token</code>. Ma nel caso di un linguaggio, l’elenco dei tipi di token è fissato ed è molto difficile che cambi.</li>
</ol></li>
<li><p>Il tipo più indicato per un <em>token</em> è un <em>sum type</em>, chiamato anche <em>tagged union</em>, che si contrappone ai <em>product type</em> che tutti voi conoscete (probabilmente senza saperlo). Vediamo in cosa consistono.</p></li>
</ul>
</section>
<section id="product-types" class="slide level1">
<h1><em>Product types</em></h1>
<ul>
<li><p>Le <code>struct</code>/<code>class</code> di linguaggi come C++, Python e Julia sono <em>product types</em>, perché dal punto di vista formale sono un <strong>prodotto cartesiano</strong> tra insiemi.</p></li>
<li><p>Consideriamo questa definizione in C++:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MyStruct {</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a;</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c;</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div>
<p>Se l’insieme di tutti i valori assumibili da un <code>int</code> e da un <code>char</code> è denominato rispettivamente con <code>I</code> e <code>C</code>, allora una variabile <code>MyStruct var</code> è tale per cui <span class="math inline">\mathtt{var} \in I \times C</span>.</p></li>
</ul>
</section>
<section id="sum-types" class="slide level1">
<h1><em>Sum types</em></h1>
<ul>
<li><p>Un <em>sum type</em> combina tra loro più tipi usando la <em>somma insiemistica</em> (ossia l’unione <span class="math inline">\cup</span>) anziché il prodotto cartesiano.</p></li>
<li><p>Nel nostro esempio C++, i <em>sum types</em> si definiscono tramite la parola chiave <code>union</code> (molto appropriata!):</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> MyStruct {</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a;</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c;</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div></li>
<li><p>In questo caso, la variabile <code>MyStruct var</code> è tale per cui <span class="math inline">\mathtt{var} \in I \cup C</span>: puo essere un <code>int</code> <strong>oppure</strong> un <code>char</code>, ma non entrambi contemporaneamente.</p></li>
</ul>
</section>
<section id="sum-types-e-token" class="slide level1">
<h1><em>Sum types</em> e <em>token</em></h1>
<ul>
<li><p>Un <em>token</em> è idealmente rappresentato da un <em>sum type</em>. Supponiamo di avere per semplicità due soli tipi di token, definiti in un codice C++:</p>
<ol>
<li><em>Literal number</em> (es., <code>150</code>), rappresentato in memoria come un <code>float</code>;</li>
<li><em>Literal string</em> (es., <code>"filename.pfm"</code>), rappresentato da <code>std::string</code>;</li>
</ol></li>
<li><p>Se i numeri appartengono all’insieme <span class="math inline">N</span> e le stringhe a <span class="math inline">S</span>, allora è chiaro che il token <code>t</code> è tale per cui <span class="math inline">\mathtt{t} \in N \cup S</span>: può essere uno dei due tipi, ma non più tipi contemporaneamente.</p></li>
</ul>
</section>
<section id="sum-types-e-token-1" class="slide level1">
<h1><em>Sum types</em> e <em>token</em></h1>
<ul>
<li><p>Potremmo allora definire il tipo <code>Token</code> in C++ nel modo seguente:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> Token {</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">float</span> number;</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>string string;</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div></li>
<li><p>Una volta assegnato un valore però non c’è modo di capire a quale dei due insiemi <span class="math inline">N</span> o <span class="math inline">S</span> appartenga l’elemento (le <code>union</code> non sono <em>tagged</em>):</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>Token my_token; my_token.number = <span class="fl">150.0</span>;  <span class="co">// This represents a &quot;literal number&quot;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>…</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (my_token.???)   <span class="co">// How can I check here if it is a &quot;literal number&quot;?</span></span></code></pre></div></li>
</ul>
</section>
<section id="tagged-unions-in-cc" class="slide level1">
<h1><em>Tagged unions</em> in C/C++</h1>
<ul>
<li><p>La soluzione è di includere le <code>union</code> in <code>struct</code>, usando <em>tre</em> tipi:</p>
<ol>
<li>Il tipo <code>Token</code> è una <code>struct</code> che contiene al suo interno il cosiddetto <em>tag</em> (che indica se il token appartiene a <span class="math inline">N</span> o a <span class="math inline">S</span>);</li>
<li>Il tipo <code>TokenType</code> è il <em>tag</em>, ed è di solito un <code>enum class</code>;</li>
<li>Il tipo <code>TokenValue</code> è la <code>union</code> vera e propria, che va corredata di un costruttore e un distruttore di default per poter essere usata in <code>Token</code>.</li>
</ol></li>
<li><p>Una volta definiti questi tipi, è possibile scrivere</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>Token my_token;</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>my_token.type = TokenType::LITERAL_NUMBER;</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>my_token.value.number = <span class="fl">150.0</span>;</span></code></pre></div></li>
</ul>
</section>
<section class="slide level1">

<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Kinds of tokens. Here we just consider two types</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> TokenType {</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  LITERAL_NUMBER,</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  LITERAL_STRING,</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="co">// The sum type.</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> TokenValue {</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> number;</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>string string;</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// The default constructor and destructor are *mandatory* for unions to</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// be used in structs/classes</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>  TokenValue() : number(<span class="fl">0.0</span>) {}</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>  ~TokenValue() {}</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a><span class="co">// Here is the &quot;Token&quot; type! We just combine `TokenType` and `TokenValue`</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a><span class="co">// in a product type, which implements a proper &quot;tagged union&quot;.</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Token {</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>  TokenType type;    <span class="co">// The &quot;tag&quot;</span></span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>  TokenValue value;  <span class="co">// The &quot;union&quot;</span></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>  Token() : type(TokenType::LITERAL_NUMBER) {}</span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div>
</section>
<section id="problemi-di-union" class="slide level1">
<h1>Problemi di <code>union</code></h1>
<ul>
<li><p>Il codice non è molto pulito; anzi, è piuttosto farraginoso!</p></li>
<li><p>Non mette al riparo da una serie di problemi:</p>
<ol>
<li><p>Sono sempre possibili inconsistenze:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>Token my_token;</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>my_token.type = TokenType::LITERAL_STRING;</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>my_token.value.number = <span class="fl">150.0</span>;   <span class="co">// Argh! The tag and the union are inconsistent!</span></span></code></pre></div></li>
<li><p>Il compilatore non può verificare che degli <code>switch</code> sul tag siano esaustivi.</p></li>
</ol></li>
</ul>
</section>
<section id="esaustività-dei-controlli" class="slide level1">
<h1>Esaustività dei controlli</h1>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Let&#39;s assume we have several token types</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> TokenType {</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  LITERAL_NUMBER,</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  LITERAL_STRING,</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  SYMBOL,</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>  KEYWORD,</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>};</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print_token(<span class="at">const</span> Token &amp; t) {</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span>(t.type) {</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> TokenType::LITERAL_NUMBER: <span class="bu">std::</span>cout &lt;&lt; t.value.number; <span class="cf">break</span>;</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> TokenType::LITERAL_STRING: <span class="bu">std::</span>cout &lt;&lt; t.value.string; <span class="cf">break</span>;</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> TokenType::LITERAL_SYMBOL: <span class="bu">std::</span>cout &lt;&lt; t.value.symbol; <span class="cf">break</span>;</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Oops! I forgot TokenType::KEYWORD!</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
</section>
<section id="sum-types-fatti-bene" class="slide level1">
<h1><em>Sum types</em> fatti bene</h1>
<ul>
<li><p>Linguaggi come Haskell, i derivati di ML (es., OCAML, F#), Rust e Swift consentono di definire <em>sum types</em> in maniera molto più naturale.</p></li>
<li><p>Ad esempio, ecco come definire il tipo <code>Token</code> in OCAML:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> token = </span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    | LiteralNumber <span class="kw">of</span> <span class="dt">float</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    | LiteralString <span class="kw">of</span> <span class="dt">string</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    | Symbol <span class="kw">of</span> <span class="dt">char</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    | Keyword <span class="kw">of</span> <span class="dt">string</span>;</span></code></pre></div>
<p>Non c’è bisogno di definire una lunga gerarchia di classi!</p></li>
</ul>
</section>
<section id="esaustività-in-ocaml" class="slide level1">
<h1>Esaustività in OCAML</h1>
<ul>
<li><p>In linguaggi come OCAML i controlli sui <em>sum types</em> sono esaustivi:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> tok = LiteralNumber <span class="fl">0.5</span>;</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> tok <span class="kw">with</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>   | LiteralNumber a -&gt; <span class="dt">print_float</span> a</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>   | LiteralString s -&gt; <span class="dt">print_string</span> s</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>   | Symbol c -&gt; <span class="dt">print_char</span> c;</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a># Warning: this pattern-matching is <span class="dt">not</span> exhaustive.</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a># Here is an example <span class="kw">of</span> a case that is <span class="dt">not</span> matched:</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a># Keyword _</span></code></pre></div></li>
<li><p>I <em>sum types</em> rappresentano gerarchie di classi «rigide», dove c’è un solo antenato (<code>token</code>) e le classi figlie sono note a priori: proprio il caso dei token! Linguaggi come OCAML sono infatti spesso usati per scrivere compilatori (es., <a href="http://www.fftw.org/fftw-paper-ieee.pdf">FFTW</a>, <a href="https://www.reddit.com/r/rust/comments/18b808/is_the_original_ocaml_compiler_still_available/">Rust</a>).</p></li>
</ul>
</section>
<section id="funzionamento-di-un-lexer" class="slide level1">
<h1>Funzionamento di un <em>lexer</em></h1>
<ul>
<li><p>Per risparmiare memoria, solitamente un <em>lexer</em> legge un carattere alla volta, e a seconda del carattere letto, «decide» che tipo di token creare.</p></li>
<li><p>Ad esempio, la lettura del carattere <code>"</code> (doppio apice) in un codice C++ indica che si sta definendo una stringa di caratteri:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">char</span> * message = <span class="st">&quot;error, you must specify an input file&quot;</span>;</span></code></pre></div>
<p>In questo caso il lexer continua a leggere finché trova un nuovo carattere <code>"</code>, che segnala la fine della stringa, e restituisce un token <em>string literal</em>.</p></li>
</ul>
</section>
<section id="ambiguità-nei-lexer" class="slide level1">
<h1>Ambiguità nei <em>lexer</em></h1>
<ul>
<li><p>Il caso di uno <em>string literal</em> è semplice da affrontare: tutte le volte che ci si imbatte in un carattere <code>"</code>, si ha a che fare con questo tipo di <em>token</em>.</p></li>
<li><p>Ma nella maggior parte dei casi un <em>lexer</em> deve affrontare ambiguità. Ad esempio, un carattere <code>a</code>…<code>z</code> indica che sta iniziando una <em>keyword</em> come <code>for</code>, oppure un <em>identifier</em> come <code>number_of_steps</code>?</p>
<p>In questo caso si leggono caratteri finché appartengono alla lista dei caratteri validi in un identificatore (solitamente lettere maiuscole/minuscole, cifre e il carattere <code>_</code>), poi si confronta la stringa letta con la lista di possibili <em>keyword</em> ammesse dal linguaggio.</p></li>
</ul>
</section>
<section id="tornare-indietro" class="slide level1">
<h1>Tornare indietro</h1>
<ul>
<li><p>In un <em>lexer</em> (e vedremo che è così anche nei <em>parser</em>) è comoda la possibilità di far sì che un carattere appena letto dal file sia «dis-letto», ossia venga rimesso a posto:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> read_char(<span class="bu">file</span>)   <span class="co"># Suppose that this returns the character &quot;X&quot;</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>unread_char(<span class="bu">file</span>, c)  <span class="co"># Puts the &quot;X&quot; back into the file</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> read_char(<span class="bu">file</span>)   <span class="co"># Read the &quot;X&quot; again</span></span></code></pre></div>
<p>Questo permette di scrivere il <em>lexer</em> in maniera più elegante.</p></li>
<li><p>L’operazione <code>unread_char</code> non fa nulla sul file (che è aperto in sola lettura!): semplicemente memorizza il carattere <code>X</code> in una variabile all’interno di <code>file</code>, e la restituisce alla successiva chiamata a <code>read_char</code>.</p></li>
</ul>
</section>
<section id="uso-di-unread_char" class="slide level1">
<h1>Uso di <code>unread_char</code></h1>
<ul>
<li><p>Perché <code>unread_char</code> è utile in un <em>lexer</em>? Vediamo per esempio questa espressione Python:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="dv">15</span><span class="op">+</span><span class="dv">4</span></span></code></pre></div>
<p>che è composta dei <em>token</em> <code>15</code> (<em>numeric literal</em>), <code>+</code> (<em>symbol</em>), <code>4</code> (<em>numeric literal</em>).</p></li>
<li><p>Quando il <em>lexer</em> inizia il suo lavoro individua il carattere <code>1</code>, e capisce che deve creare un token <em>numeric literal</em>. A questo punto deve leggere i caratteri finché trova la prima non-cifra, che è <code>+</code>. Ma una volta letto <code>+</code>, deve rimetterla a posto perché fa parte del token successivo.</p></li>
</ul>
</section>
<section id="lettura-di-un-numeric-literal" class="slide level1">
<h1>Lettura di un <em>numeric literal</em></h1>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>ch <span class="op">=</span> read_char()</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Very basic and ugly code! It does not interpret negative numbers!</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> ch.isdigit():</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We have a numeric literal here!</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    literal <span class="op">=</span> ch</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>        ch <span class="op">=</span> read_char()  <span class="co"># Read the next character</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> ch.isdigit():</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>            <span class="co"># We have got the next digit for the current numeric literal</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>            literal <span class="op">+=</span> ch</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>            <span class="co"># The number has ended, so put the last character back in place</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.unread_char(ch)</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>        value <span class="op">=</span> <span class="bu">int</span>(literal)</span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">ValueError</span>:</span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;invalid numeric literal </span><span class="sc">{</span>literal<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
</section>
<section id="condizioni-di-errore" class="slide level1">
<h1>Condizioni di errore</h1>
<ul>
<li><p>Già nella scrittura del <em>lexer</em>, prima di occuparsi dell’aspetto sintattico e semantico, è possibile imbattersi in errori nel codice.</p></li>
<li><p>Ad esempio, la presenza di un carattere come <code>@</code> non è ammessa nel nostro linguaggio, e già il <em>lexer</em> può individuare questo tipo di errore.</p></li>
<li><p>Un altro esempio è la dimenticanza di chiudere il doppio apice <code>"</code> alla fine di una stringa.</p></li>
</ul>
</section>
<section id="come-segnalare-errori" class="slide level1">
<h1>Come segnalare errori</h1>
<ul>
<li><p>Nei compilatori moderni, il tipo <code>Token</code> contiene al suo interno anche informazioni sulla posizione del token nel file sorgente (vedi ad esempio il tipo <a href="https://github.com/llvm/llvm-project/blob/llvmorg-10.0.0/clang/include/clang/Lex/Token.h"><code>Token</code></a> nella versione 10.0.0 del compilatore Clang: non è un’implementazione molto elegante, ma è ottimizzata per essere efficiente!).</p></li>
<li><p>Questa informazione serve al <em>lexer</em> e al <em>parser</em> per stampare messaggi d’errore come il seguente (prodotto da Clang 10):</p>
<pre class="text"><code>test.cpp:31:15: error: no viable conversion from &#39;int&#39; to &#39;std::string&#39;
      (aka &#39;basic_string&lt;char&gt;&#39;)
  std::string message = 127;
              ^         ~~~</code></pre>
<p>dove viene indicato il nome del file (<code>test.cpp</code>), il numero della riga (<code>31</code>) e il numero della colonna (<code>15</code>) in cui è stato trovato l’errore.</p></li>
</ul>
</section>
<section id="tracciare-posizioni" class="slide level1">
<h1>Tracciare posizioni</h1>
<ul>
<li><p>La posizione di un token in un file è identificata da tre informazioni:</p>
<ol>
<li>Il nome del file sorgente (una stringa);</li>
<li>Il numero della riga (un intero, numerato partendo da 1);</li>
<li>Il numero della colonna (idem).</li>
</ol></li>
<li><p>Il tipo <code>Token</code> dovrebbe quindi contenere anche questi tre campi. Se usate una gerarchia di classi (come in pytracer) potete implementarle direttamente nel tipo, oppure definite un tipo <code>SourceLocation</code> (come fa Clang).</p></li>
</ul>
</section>
    </div>
  </div>

  <script src="https://unpkg.com/reveal.js@^4//dist/reveal.js"></script>

  // reveal.js plugins
  <script src="https://unpkg.com/reveal.js@^4//plugin/notes/notes.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/search/search.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/zoom/zoom.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display a presentation progress bar
        progress: true,
        // Display the page number of the current slide
        slideNumber: true,
        // Push each slide change to the browser history
        history: true,
       // Parallax background image
       parallaxBackgroundImage: './media/background.png', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"
        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1440,
        height: 810,

        // reveal.js plugins
        plugins: [
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script src="js/asciinema-player.js"></script>
    <script src="https://cdn.plot.ly/plotly-1.58.4.min.js"></script>
    <script type="text/javascript" src="./js/quantization.js"></script>
    </body>
</html>
