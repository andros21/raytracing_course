<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Maurizio Tomasi maurizio.tomasi@unimi.it">
  <title>Esercitazione 3</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/theme/white.css" id="theme">
  <link rel="stylesheet" href="./css/custom.css"/>
  <link rel="stylesheet" href="./css/asciinema-player.css"/>
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Esercitazione 3</h1>
  <p class="subtitle">Calcolo numerico per la generazione di immagini fotorealistiche</p>
  <p class="author">Maurizio Tomasi <a href="mailto:maurizio.tomasi@unimi.it" class="email">maurizio.tomasi@unimi.it</a></p>
</section>

<section id="il-tipo-hdrimage" class="slide level1">
<h1>Il tipo <code>HdrImage</code></h1>
<ul>
<li>Oggi implementeremo un tipo <code>HdrImage</code>, che useremo per rappresentare una immagine HDR tramite una matrice di colori (del tipo <code>Color</code>).</li>
<li>Il tipo <code>HdrImage</code> dovrà implementare queste funzionalità:
<ul>
<li>Creazione di un’immagine vuota;</li>
<li>Lettura/scrittura di pixel;</li>
<li>Caricamento di immagini in formato PFM.</li>
</ul></li>
</ul>
</section>
<section id="implementazione-di-hdrimage" class="slide level1">
<h1>Implementazione di <code>HdrImage</code></h1>
<ul>
<li>Deve avere tre campi:
<ul>
<li><code>width</code> ed <code>height</code> (numero di colonne e di righe della matrice);</li>
<li>Array di valori <code>Color</code>.</li>
</ul></li>
<li>Servono due costruttori/funzioni:
<ul>
<li>Creare un’immagine vuota partendo da una risoluzione;</li>
<li>Scrivere un’immagine in un file PFM.</li>
</ul></li>
<li>Ovviamente vogliamo anche una serie completa di test!</li>
</ul>
</section>
<section id="matrice-dei-colori" class="slide level1">
<h1>Matrice dei colori</h1>
<ul>
<li><p>Il tipo più naturale per una matrice di colori è un array bidimensionale di dimensione <code>(ncols, nrows)</code>…</p></li>
<li><p>…ma per certi versi è più comodo usare un array <strong>monodimensionale</strong> di dimensione <code>ncols × nrows</code>.</p></li>
<li><p>In Python possiamo implementare <code>HdrImage</code> così:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> HdrImage:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, width<span class="op">=</span><span class="dv">0</span>, height<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        (<span class="va">self</span>.width, <span class="va">self</span>.height) <span class="op">=</span> (width, height)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.pixels <span class="op">=</span> [Color() <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.width <span class="op">*</span> <span class="va">self</span>.height)]</span></code></pre></div></li>
</ul>
</section>
<section id="accesso-ai-pixel" class="slide level1">
<h1>Accesso ai pixel</h1>
<p>Data la posizione <code>(x, y)</code> di un pixel (con <code>x</code> colonna e <code>y</code> riga), l’indice nell’array <code>self.pixels</code> si trova così:</p>
<center>
<img data-src="./media/bitmap-linear-access.svg" />
</center>
</section>
<section id="get_pixel-e-set_pixel" class="slide level1">
<h1><code>get_pixel</code> e <code>set_pixel</code></h1>
<ul>
<li><p>Usando la formula della slide precedente possiamo implementare i metodi <code>get_pixel</code> e <code>set_pixel</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_pixel(<span class="va">self</span>, x, y):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> (x <span class="op">&gt;=</span> <span class="dv">0</span>) <span class="kw">and</span> (x <span class="op">&lt;</span> <span class="va">self</span>.width)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> (y <span class="op">&gt;=</span> <span class="dv">0</span>) <span class="kw">and</span> (y <span class="op">&lt;</span> <span class="va">self</span>.height)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">self</span>.pixels[y <span class="op">*</span> <span class="va">self</span>.height <span class="op">+</span> x]</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> set_pixel(<span class="va">self</span>, x, y, new_color):</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> (x <span class="op">&gt;=</span> <span class="dv">0</span>) <span class="kw">and</span> (x <span class="op">&lt;</span> <span class="va">self</span>.width)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> (y <span class="op">&gt;=</span> <span class="dv">0</span>) <span class="kw">and</span> (y <span class="op">&lt;</span> <span class="va">self</span>.height)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.pixels[y <span class="op">*</span> <span class="va">self</span>.height <span class="op">+</span> x] <span class="op">=</span> new_color</span></code></pre></div></li>
<li><p>Ma questa implementazione è la migliore?</p></li>
</ul>
</section>
<section id="test-e-granularità" class="slide level1">
<h1>Test e granularità</h1>
<ul>
<li><p>L’implementazione di funzioni e tipi dovrebbe essere legata alla scrittura di test.</p></li>
<li><p><strong>Non</strong> è semplice implementare test per le due funzioni:</p>
<ul>
<li>Ciascuna fa troppe cose insieme, che vanno testate tutte!</li>
<li>Ci sono test che vanno ripetuti per <code>get_pixel</code> e <code>set_pixel</code>, ossia la validità delle coordinate e la correttezza nel calcolo dell’indice.</li>
</ul></li>
</ul>
</section>
<section id="test-ripetuti" class="slide level1">
<h1>Test ripetuti</h1>
<ul>
<li><p>Dobbiamo verificare che coordinate sbagliate vengano rigettate sia in <code>set_pixel</code> che in <code>get_pixel</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>img <span class="op">=</span> HdrImage(<span class="dv">7</span>, <span class="dv">4</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Test that wrong positions be signaled</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pytest.raises(<span class="pp">AssertionError</span>):</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    img.get_pixel(<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co"># We must redo the same for &quot;set_pixel&quot;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> pytest.raises(<span class="pp">AssertionError</span>):</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    img.set_pixel(<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, Color())</span></code></pre></div></li>
<li><p>Possiamo fare di meglio <em>modularizzando</em> il codice, ossia decomponendolo in parti più semplici (che è un vantaggio già di per sè).</p></li>
</ul>
</section>
<section id="nuova-implementazione" class="slide level1">
<h1>Nuova implementazione</h1>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> valid_coordinates(<span class="va">self</span>, x, y):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ((x <span class="op">&gt;=</span> <span class="dv">0</span>) <span class="kw">and</span> (x <span class="op">&lt;</span> <span class="va">self</span>.width) <span class="kw">and</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>            (y <span class="op">&gt;=</span> <span class="dv">0</span>) <span class="kw">and</span> (y <span class="op">&lt;</span> <span class="va">self</span>.height))</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pixel_offset(<span class="va">self</span>, x, y):</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y <span class="op">*</span> <span class="va">self</span>.height <span class="op">+</span> x</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_pixel(<span class="va">self</span>, x, y):</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="va">self</span>.valid_coordinates(x, y)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">self</span>.pixels[<span class="va">self</span>.pixel_offset(x, y)]</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> set_pixel(<span class="va">self</span>, x, y, new_color):</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="va">self</span>.valid_coordinates(x, y)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.pixels[<span class="va">self</span>.pixel_offset(x, y)] <span class="op">=</span> new_color</span></code></pre></div>
</section>
<section id="test" class="slide level1">
<h1>Test</h1>
<ul>
<li><p>Questi sono i test scritti per la nuova implementazione:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>img <span class="op">=</span> HdrImage(<span class="dv">7</span>, <span class="dv">4</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Check that valid/invalid coordinates are properly flagged</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> img.valid_coordinates(<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> img.valid_coordinates(<span class="dv">6</span>, <span class="dv">3</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="kw">not</span> img.valid_coordinates(<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="kw">not</span> img.valid_coordinates(<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Check that indices in the array are calculated correctly:</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co"># this kind of test would have been harder to write</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co"># in the old implementation</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> img.pixel_offset(<span class="dv">3</span>, <span class="dv">2</span>) <span class="op">==</span> <span class="dv">17</span>    <span class="co"># See the plot a few slides before</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> img.pixel_offset(<span class="dv">6</span>, <span class="dv">3</span>) <span class="op">==</span> <span class="dv">7</span> <span class="op">*</span> <span class="dv">4</span> <span class="op">-</span> <span class="dv">1</span></span></code></pre></div></li>
<li><p>Questi sono detti <em>unit test</em>, perché vanno a verificare le singole «unità» di codice.</p></li>
</ul>
</section>
<section id="scritturalettura-di-file" class="slide level1">
<h1>Scrittura/lettura di file</h1>
</section>
<section id="file-pfm" class="slide level1">
<h1>File PFM</h1>
<ul>
<li><p>La classe <code>HdrImage</code> deve essere in grado di caricare e salvare immagini PFM.</p></li>
<li><p>Abbiamo visto che i file PFM sono scritti in forma <em>binaria</em>, anche se includono parti di testo.</p></li>
<li><p>In che modo i linguaggi di programmazione che usiamo supportano l’accesso ai file?</p></li>
<li><p>Come distinguere tra file binari e testuali?</p></li>
</ul>
</section>
<section id="accesso-ai-file-in-python" class="slide level1">
<h1>Accesso ai file in Python</h1>
<p><asciinema-player src="./cast/binary-text-files-75x25.cast" cols="75" rows="25" font-size="medium"></asciinema-player></p>
</section>
<section id="file-di-testobinari" class="slide level1">
<h1>File di testo/binari</h1>
<ul>
<li>Non è possibile in generale dire se un file è codificato in forma testuale o binaria.</li>
<li>Le estensioni dei file possono essere usate per capire il formato (ma si possono sempre prendere svarioni!).</li>
<li>Python mostra che file binari usano tipi di dati (<code>b"Hello, world!\n"</code>) diversi da quelli dei file di testo (<code>"Hello, world!\n"</code>).</li>
<li>Tutti i linguaggi (Python 3, Julia, C#, Kotlin, etc.) supportano nativamente Unicode e gestiscono correttamente questa differenza…</li>
<li>…con l’eccezione del C++ (<a href="https://stackoverflow.com/questions/31302506/stdu32string-conversion-to-from-stdstring-and-stdu16string">è</a> <a href="https://stackoverflow.com/questions/17103925/how-well-is-unicode-supported-in-c11">una</a> <a href="https://stackoverflow.com/questions/2259544/is-wchar-t-needed-for-unicode-support">triste</a> <a href="https://stackoverflow.com/questions/48816848/what-is-the-efficient-standards-compliant-mechanism-for-processing-unicode-usin">storia</a>).</li>
</ul>
</section>
<section id="immagini-pfm" class="slide level1">
<h1>Immagini PFM</h1>
<ul>
<li><p>Scrivere file PFM è relativamente banale, perché hanno un <a href="http://www.pauldebevec.com/Research/HDR/PFM/">formato</a> molto semplice (decisamente più semplice dei file PPM visti a lezione!)</p></li>
<li><p>Un file PFM deve iniziare con questi caratteri (tutti ASCII, quindi non dobbiamo preoccuparci di Unicode):</p>
<pre class="text"><code>PF
width height
±1.0</code></pre>
<p>dove <code>width</code> ed <code>height</code> sono la larghezza (numero di colonne) e l’altezza (numero di righe) dell’immagine; seguono poi i valori RGB in binario.</p></li>
<li><p>I ritorni a capo vanno codificati come <code>\n</code> (non c’è ambiguità Windows/DOS/Linux/etc. come per i file di testo).</p></li>
</ul>
</section>
<section id="il-numero-1.0" class="slide level1">
<h1>Il numero <code>±1.0</code></h1>
<ul>
<li><p>La terza riga dell’header del file deve contenere <code>1.0</code> oppure <code>-1.0</code>.</p></li>
<li><p>Questo numero serve per segnalare il modo in cui ciascuna delle componenti RGB di un colore (floating-point a 32 bit) viene codificata:</p>
<ol type="1">
<li>Il valore <code>1.0</code> indica che si usa la codifica <em>big endian</em>;</li>
<li>Il valore <code>-1.0</code> indica che si usa la codifica <em>little endian</em>.</li>
</ol></li>
</ul>
</section>
<section id="numeri-in-binario" class="slide level1">
<h1>Numeri in binario</h1>
<ul>
<li><p>Per scrivere numeri in binario, ogni linguaggio offre una serie di opzioni.</p></li>
<li><p>In Python basta usare <code>import struct</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _write_float(stream, value):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Meaning of &quot;&lt;f&quot;:</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># &quot;&lt;&quot;: little endian</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># &quot;f&quot;: single-precision floating point value (32 bit)</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    stream.write(struct.pack(<span class="st">&quot;&lt;f&quot;</span>, value))</span></code></pre></div></li>
</ul>
</section>
<section id="api-di-hdrimage" class="slide level1">
<h1>API di <code>HdrImage</code></h1>
<ul>
<li><p>Il modo in cui un tipo di dato o una funzione deve essere usato dal programmatore si chiama <em>Application Program Interface</em> (API).</p></li>
<li><p>Nel nostro caso, la API per scrivere un file PFM consiste nel modo in cui invocheremmo una funzione <code>write_pfm</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Our API requires the name of the file</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>img.write_pfm(<span class="st">&quot;output_file.pfm&quot;</span>)</span></code></pre></div></li>
<li><p>Il tipo di API dovrebbe essere modellato anche in funzione dei test che si devono scrivere su di essa.</p></li>
</ul>
</section>
<section id="test-ed-api" class="slide level1">
<h1>Test ed API</h1>
<ul>
<li><p>Consideriamo il caso di <code>write_pfm</code>. Come dovremmo scrivere un test su questa funzione?</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>img <span class="op">=</span> HdrImage(<span class="dv">7</span>, <span class="dv">4</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>img.write_pfm(<span class="st">&quot;output_file.pfm&quot;</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> ...  <span class="co"># Now what?</span></span></code></pre></div></li>
<li><p>Se la funzione scrive su file, vuol dire che dovremmo poi <em>caricare</em> il file e verificare che sia stato scritto correttamente.</p></li>
<li><p>Ciò significa che finché non abbiamo una routine parallela <code>read_pfm</code> non possiamo testare <code>write_pfm</code>?</p></li>
</ul>
</section>
<section id="gestione-dei-file" class="slide level1">
<h1>Gestione dei file</h1>
<ul>
<li><p>Dobbiamo investigare meglio il modo in cui i file possono essere manipolati nei programmi.</p></li>
<li><p>Potete pensare a un file binario come a un vettore (array monodimensionale) di byte, in sequenza uno dopo l’altro. (Un file testuale è lo stesso, ma nella codifica UTF è una sequenza di <em>code point</em> anziché byte, e la cosa è un po’ più complicata).</p></li>
<li><p>I linguaggi moderni introducono una astrazione: lo <em>stream</em>.</p></li>
<li><p>Questa astrazione è molto utile nei test.</p></li>
</ul>
</section>
<section id="file-e-stream" class="slide level1">
<h1>File e stream</h1>
<ul>
<li><p>Semplificando, uno <em>stream</em> è un oggetto in grado di compiere queste operazioni:</p>
<ol type="1">
<li>Restituire un byte alla volta leggendolo da una sequenza;</li>
<li>Scrivere un byte alla volta, aggiungendolo in coda a quelli già scritti.</li>
</ol></li>
<li><p>Queste due operazioni sono quelle che tipicamente si fanno sui file, ma uno <em>stream</em> è applicabile anche ad altri contesti:</p>
<ol type="1">
<li>Una connessione di rete a un server remoto funziona come uno stream;</li>
<li>La stessa memoria RAM può essere considerata come uno stream; di conseguenza, una sequenza di byte in memoria può essere vista come uno stream, se il linguaggio lo supporta.</li>
</ol></li>
</ul>
</section>
<section id="esempio-in-python" class="slide level1">
<h1>Esempio in Python</h1>
<p><asciinema-player src="./cast/files-streams-75x25.cast" cols="75" rows="25" font-size="medium"></asciinema-player></p>
</section>
<section id="stream-api-e-test" class="slide level1">
<h1>Stream, API e test</h1>
<ul>
<li><p>Potremmo pensare di modificare la nostra API in modo che scriva in un generico stream, come l’esempio <code>write_hello</code> nel video:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>stream <span class="op">=</span> CreateSomeStream(...)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>img.write_pfm(stream)</span></code></pre></div></li>
<li><p>Quando il programma è in esecuzione, faremo in modo che <code>stream</code> sia un file vero.</p></li>
<li><p>Quando dobbiamo eseguire un test, possiamo invece fare in modo che <code>stream</code> sia una variabile in memoria. I byte non verranno quindi scritti su file, ma mantenuti in un vettore di byte, su cui eseguiremo degli <code>assert</code>.</p></li>
</ul>
</section>
<section id="il-metodo-write_pfm" class="slide level1">
<h1>Il metodo <code>write_pfm</code></h1>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> write_pfm(<span class="va">self</span>, stream):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The PFM header, as a Python string (UTF-8)</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    header <span class="op">=</span> <span class="ss">f&quot;PF</span><span class="ch">\n</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>width<span class="sc">}</span><span class="ss"> </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>height<span class="sc">}</span><span class="ch">\n</span><span class="ss">-1.0</span><span class="ch">\n</span><span class="ss">&quot;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert the header into a sequence of bytes</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    stream.write(header.encode(<span class="st">&quot;utf-8&quot;</span>))</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Write the image (bottom-to-up, left-to-right)</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">reversed</span>(<span class="bu">range</span>(<span class="va">self</span>.height)):</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.width):</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>            color <span class="op">=</span> <span class="va">self</span>.get_pixel(x, y)</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>            _write_float(stream, color.r)</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>            _write_float(stream, color.g)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>            _write_float(stream, color.b)</span></code></pre></div>
</section>
<section id="immagine-per-i-test" class="slide level1">
<h1>Immagine per i test</h1>
<ul>
<li><p>Ho creato un file PFM con queste caratteristiche:</p>
<ul>
<li><p>Dimensioni: 3 pixel × 2 pixel</p></li>
<li><p>Matrice dei colori (RGB):</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>#1</th>
<th>#2</th>
<th>#3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>#A</td>
<td>(10, 20, 30)</td>
<td>(40, 50, 60)</td>
<td>(70, 80, 90)</td>
</tr>
<tr class="even">
<td>#B</td>
<td>(100, 200, 300)</td>
<td>(400, 500, 600)</td>
<td>(700, 800, 900)</td>
</tr>
</tbody>
</table></li>
</ul></li>
<li><p>Se volete il file, scaricatelo con nome <a href="./media/reference.pfm"><code>reference.pfm</code></a> e salvatelo nel vostro repository, possibilmente nella stessa directory dei test.</p></li>
</ul>
</section>
<section id="scrittura-del-test-13" class="slide level1">
<h1>Scrittura del test (1/3)</h1>
<p>Il primo approccio è quello di leggere il file <code>reference.pfm</code> e confrontarlo col file che <em>sarebbe</em> stato scritto da <code>write_pfm</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>img <span class="op">=</span> HdrImage(<span class="dv">3</span>, <span class="dv">2</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>img.set_pixel(<span class="dv">0</span>, <span class="dv">0</span>, Color(<span class="fl">1.0e1</span>, <span class="fl">2.0e1</span>, <span class="fl">3.0e1</span>)) <span class="co"># Each component is</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>img.set_pixel(<span class="dv">1</span>, <span class="dv">0</span>, Color(<span class="fl">4.0e1</span>, <span class="fl">5.0e1</span>, <span class="fl">6.0e1</span>)) <span class="co"># different from any</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>img.set_pixel(<span class="dv">2</span>, <span class="dv">0</span>, Color(<span class="fl">7.0e1</span>, <span class="fl">8.0e1</span>, <span class="fl">9.0e1</span>)) <span class="co"># other: important in</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>img.set_pixel(<span class="dv">0</span>, <span class="dv">1</span>, Color(<span class="fl">1.0e2</span>, <span class="fl">2.0e2</span>, <span class="fl">3.0e2</span>)) <span class="co"># tests!</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>img.set_pixel(<span class="dv">1</span>, <span class="dv">1</span>, Color(<span class="fl">4.0e2</span>, <span class="fl">5.0e2</span>, <span class="fl">6.0e2</span>))</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>img.set_pixel(<span class="dv">2</span>, <span class="dv">1</span>, Color(<span class="fl">7.0e2</span>, <span class="fl">8.0e2</span>, <span class="fl">9.0e2</span>))</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">&quot;reference.pfm&quot;</span>, <span class="st">&quot;wb&quot;</span>) <span class="im">as</span> inpf:</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    reference_bytes <span class="op">=</span> inpf.readall()</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>buf <span class="op">=</span> BytesIO()</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>img.write_pfm(buf)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> buf.getvalue() <span class="op">==</span> reference_bytes</span></code></pre></div>
</section>
<section id="scrittura-dei-test-23" class="slide level1">
<h1>Scrittura dei test (2/3)</h1>
<p>Ma se eseguiamo <code>xxd</code> sul file <code>reference.pfm</code>, possiamo ottenere la sequenza di valori dei byte nel formato C/C++:</p>
<pre class="text"><code>$ xxd -i reference.pfm
unsigned char reference_pfm[] = {
  0x50, 0x46, 0x0a, 0x33, 0x20, 0x32, 0x0a, 0x2d, 0x31, 0x2e, 0x30, 0x0a,
  0x00, 0x00, 0xc8, 0x42, 0x00, 0x00, 0x48, 0x43, 0x00, 0x00, 0x96, 0x43,
  0x00, 0x00, 0xc8, 0x43, 0x00, 0x00, 0xfa, 0x43, 0x00, 0x00, 0x16, 0x44,
  0x00, 0x00, 0x2f, 0x44, 0x00, 0x00, 0x48, 0x44, 0x00, 0x00, 0x61, 0x44,
  0x00, 0x00, 0x20, 0x41, 0x00, 0x00, 0xa0, 0x41, 0x00, 0x00, 0xf0, 0x41,
  0x00, 0x00, 0x20, 0x42, 0x00, 0x00, 0x48, 0x42, 0x00, 0x00, 0x70, 0x42,
  0x00, 0x00, 0xc8, 0x42, 0x00, 0x00, 0x48, 0x43, 0x00, 0x00, 0x96, 0x43
};
unsigned int reference_pfm_len = 84;</code></pre>
</section>
<section id="scrittura-dei-test-33" class="slide level1">
<h1>Scrittura dei test (3/3)</h1>
<p>Se inseriamo questa sequenza di byte nel nostro programma, possiamo fare un confronto diretto in memoria:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create &quot;img&quot; as in the previous case, then…</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>reference_bytes <span class="op">=</span> <span class="bu">bytes</span>([</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="bn">0x50</span>, <span class="bn">0x46</span>, <span class="bn">0x0a</span>, <span class="bn">0x33</span>, <span class="bn">0x20</span>, <span class="bn">0x32</span>, <span class="bn">0x0a</span>, <span class="bn">0x2d</span>, <span class="bn">0x31</span>, <span class="bn">0x2e</span>, <span class="bn">0x30</span>, <span class="bn">0x0a</span>,</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xc8</span>, <span class="bn">0x42</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x48</span>, <span class="bn">0x43</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x96</span>, <span class="bn">0x43</span>,</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xc8</span>, <span class="bn">0x43</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xfa</span>, <span class="bn">0x43</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x16</span>, <span class="bn">0x44</span>,</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x2f</span>, <span class="bn">0x44</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x48</span>, <span class="bn">0x44</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x61</span>, <span class="bn">0x44</span>,</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x20</span>, <span class="bn">0x41</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xa0</span>, <span class="bn">0x41</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xf0</span>, <span class="bn">0x41</span>,</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x20</span>, <span class="bn">0x42</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x48</span>, <span class="bn">0x42</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x70</span>, <span class="bn">0x42</span>,</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xc8</span>, <span class="bn">0x42</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x48</span>, <span class="bn">0x43</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x96</span>, <span class="bn">0x43</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="co"># No file is being read/written here!</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>buf <span class="op">=</span> BytesIO()</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>img.write_pfm(buf)</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> buf.getvalue() <span class="op">==</span> reference_bytes</span></code></pre></div>
</section>
<section id="guida-per-lesercitazione" class="slide level1">
<h1>Guida per l’esercitazione</h1>
</section>
<section id="guida-per-lesercitazione-1" class="slide level1">
<h1>Guida per l’esercitazione</h1>
<ol type="1">
<li><p>Implementate il tipo <code>HdrImage</code> con le seguenti caratteristiche:</p>
<ul>
<li>Campi <code>width</code> ed <code>height</code>, array di valori <code>Color</code>;</li>
<li>Salvataggio in formato PFM.</li>
</ul>
<p>Il tipo andrebbe salvato in un file a parte, nella stessa directory dove settimana scorsa avete salvato il file che implementa il tipo <code>Color</code>.</p></li>
<li><p>Implementate una serie di test per le funzioni del punto precedente.</p></li>
</ol>
</section>
<section id="test-1" class="slide level1">
<h1>Test (1)</h1>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_image_creation():</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    img <span class="op">=</span> HdrImage(<span class="dv">7</span>, <span class="dv">4</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> img.width <span class="op">==</span> <span class="dv">7</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> img.height <span class="op">==</span> <span class="dv">4</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_coordinates():</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    img <span class="op">=</span> HdrImage(<span class="dv">7</span>, <span class="dv">4</span>)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> img.valid_coordinates(<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> img.valid_coordinates(<span class="dv">6</span>, <span class="dv">3</span>)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="kw">not</span> img.valid_coordinates(<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="kw">not</span> img.valid_coordinates(<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_pixel_offset():</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    img <span class="op">=</span> HdrImage(<span class="dv">7</span>, <span class="dv">4</span>)</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> img.pixel_offset(<span class="dv">0</span>, <span class="dv">0</span>) <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> img.pixel_offset(<span class="dv">3</span>, <span class="dv">2</span>) <span class="op">==</span> <span class="dv">17</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> img.pixel_offset(<span class="dv">6</span>, <span class="dv">3</span>) <span class="op">==</span> <span class="dv">7</span> <span class="op">*</span> <span class="dv">4</span> <span class="op">-</span> <span class="dv">1</span></span></code></pre></div>
</section>
<section id="test-2" class="slide level1">
<h1>Test (2)</h1>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_get_set_pixel():</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    img <span class="op">=</span> HdrImage(<span class="dv">7</span>, <span class="dv">4</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    reference_color <span class="op">=</span> Color(<span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">3.0</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    img.set_pixel(<span class="dv">3</span>, <span class="dv">2</span>, reference_color)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> are_colors_close(reference_color, img.get_pixel(<span class="dv">3</span>, <span class="dv">2</span>))</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_pfm_save():</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    img <span class="op">=</span> HdrImage(<span class="dv">3</span>, <span class="dv">2</span>)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    img.set_pixel(<span class="dv">0</span>, <span class="dv">0</span>, Color(<span class="fl">1.0e1</span>, <span class="fl">2.0e1</span>, <span class="fl">3.0e1</span>)) <span class="co"># Each component is</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    img.set_pixel(<span class="dv">1</span>, <span class="dv">0</span>, Color(<span class="fl">4.0e1</span>, <span class="fl">5.0e1</span>, <span class="fl">6.0e1</span>)) <span class="co"># different from any</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    img.set_pixel(<span class="dv">2</span>, <span class="dv">0</span>, Color(<span class="fl">7.0e1</span>, <span class="fl">8.0e1</span>, <span class="fl">9.0e1</span>)) <span class="co"># other: important in</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    img.set_pixel(<span class="dv">0</span>, <span class="dv">1</span>, Color(<span class="fl">1.0e2</span>, <span class="fl">2.0e2</span>, <span class="fl">3.0e2</span>)) <span class="co"># tests!</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    img.set_pixel(<span class="dv">1</span>, <span class="dv">1</span>, Color(<span class="fl">4.0e2</span>, <span class="fl">5.0e2</span>, <span class="fl">6.0e2</span>))</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    img.set_pixel(<span class="dv">2</span>, <span class="dv">1</span>, Color(<span class="fl">7.0e2</span>, <span class="fl">8.0e2</span>, <span class="fl">9.0e2</span>))</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    reference_bytes <span class="op">=</span> <span class="bu">bytes</span>([</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>        <span class="bn">0x50</span>, <span class="bn">0x46</span>, <span class="bn">0x0a</span>, <span class="bn">0x33</span>, <span class="bn">0x20</span>, <span class="bn">0x32</span>, <span class="bn">0x0a</span>, <span class="bn">0x2d</span>, <span class="bn">0x31</span>, <span class="bn">0x2e</span>, <span class="bn">0x30</span>, <span class="bn">0x0a</span>,</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>        <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xc8</span>, <span class="bn">0x42</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x48</span>, <span class="bn">0x43</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x96</span>, <span class="bn">0x43</span>,</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>        <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xc8</span>, <span class="bn">0x43</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xfa</span>, <span class="bn">0x43</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x16</span>, <span class="bn">0x44</span>,</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>        <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x2f</span>, <span class="bn">0x44</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x48</span>, <span class="bn">0x44</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x61</span>, <span class="bn">0x44</span>,</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>        <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x20</span>, <span class="bn">0x41</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xa0</span>, <span class="bn">0x41</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xf0</span>, <span class="bn">0x41</span>,</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>        <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x20</span>, <span class="bn">0x42</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x48</span>, <span class="bn">0x42</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x70</span>, <span class="bn">0x42</span>,</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>        <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xc8</span>, <span class="bn">0x42</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x48</span>, <span class="bn">0x43</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x96</span>, <span class="bn">0x43</span></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>    buf <span class="op">=</span> BytesIO()</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>    img.write_pfm(buf)</span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> buf.getvalue() <span class="op">==</span> reference_bytes</span></code></pre></div>
</section>
<section id="lavoro-in-gruppo" class="slide level1">
<h1>Lavoro in gruppo</h1>
<ul>
<li><p>Per iniziare il lavoro, occorre che <strong>uno solo</strong> di voi implementi lo scheletro del tipo <code>HdrImage</code>; basta la sua dichiarazione, ad esempio il file <code>.h</code> in C++.</p></li>
<li><p>Una volta fatto <code>git push</code>, prelevate in locale con <code>git pull</code>, e fate che uno di voi implementi il metodo e l’altro scriva <strong>contemporaneamente</strong> il test:</p>
<ul>
<li><code>valid_coordinates</code> + test;</li>
<li><code>pixel_offset</code> + test;</li>
<li><code>get_pixel</code>/<code>set_pixel</code> + test;</li>
<li><code>save_pfm</code> + test.</li>
</ul></li>
<li><p>Non abbiate paura di fare <em>merge commit</em>: più vi esercitate con essi, più semplice vi sarà la vita in futuro.</p></li>
</ul>
</section>
<section id="linguaggi" class="slide level1">
<h1>Linguaggi</h1>
<ul>
<li><p>Come le scorse volte, vi do una serie di indicazioni per l’implementazione nei vari linguaggi.</p></li>
<li><p>Sono presenti in ogni slide una serie di link alla documentazione del linguaggio: imparate a consultarla e a prendere familiarità col modo in cui è organizzata!</p></li>
<li><p>Via via che procederemo dovrete essere sempre più autonomi nel trovare soluzioni per il vostro linguaggio, e a diventare confidenti con la sua sintassi.</p></li>
</ul>
</section>
<section id="link-a-gather" class="slide level1">
<h1>Link a Gather</h1>
<ul>
<li>Useremo il solito link: https://gather.town/app/CgOtJvyNfVKMIQ9e/LaboratorioRayTracing</li>
</ul>
</section>
<section id="indicazioni-per-c" class="slide level1">
<h1>Indicazioni per C++</h1>
</section>
<section id="il-tipo-hdrimage-1" class="slide level1">
<h1>Il tipo <code>HdrImage</code></h1>
<ul>
<li><p>Usate <code>std::vector&lt;Color&gt;</code> per l’array di colori in <code>HdrImage</code>;</p></li>
<li><p>Non c’è bisogno di implementare funzioni <code>getWidth</code>, <code>setWidth</code>, eccetera. Basta che <code>width</code>, <code>height</code> e <code>pixels</code> siano membri pubblici:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> HdrImage {</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> width, height;</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector&lt;Color&gt; pixels;</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div></li>
<li><p>Sarebbe meglio dichiarare i metodi <code>valid_coordinates</code>, <code>pixel_index</code>, <code>get_pixel</code> e <code>set_pixel</code> nel file <code>.h</code> anziché nel <code>.cpp</code>.</p></li>
</ul>
</section>
<section id="file-e-stream-1" class="slide level1">
<h1>File e stream</h1>
<ul>
<li><p>Per accedere ai file, il C++ non è molto sofisticato: aprite il file in scrittura usando <code>std::ofstream</code>.</p></li>
<li><p>Gli stream in memoria (come <code>ByteIO</code> in Python) sono implementati da <a href="https://www.cplusplus.com/reference/sstream/stringstream/stringstream/"><code>std::stringstream</code></a> (in <code>&lt;sstream&gt;</code>):</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>stringstream sstr;</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>sstr &lt;&lt; <span class="st">&quot;PF</span><span class="sc">\n</span><span class="st">&quot;</span> &lt;&lt; width &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; height &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> &lt;&lt; endianness;</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string result{sstr.str()};</span></code></pre></div></li>
</ul>
</section>
<section id="scrittura-di-dati-binari" class="slide level1">
<h1>Scrittura di dati binari</h1>
<ul>
<li><p>Il C++ non offre molti strumenti per scomporre una variabile <code>float</code> nei suoi quattro byte.</p></li>
<li><p>Bisogna lavorare un po’ di puntatori, e fare attenzione al fatto che solo scrivendo <code>uint8_t</code> in un file si usa la rappresentazione binaria:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstdint&gt;</span><span class="pp">  </span><span class="co">// It contains uint8_t</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">// This assumes a little-endian architecture</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> write_float(<span class="bu">std::</span>ofstream &amp; stream, <span class="dt">float</span> value) {</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint8_t</span> * ptr{(<span class="dt">char</span> *)&amp;value};</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// sizeof(value): number of bytes used for &quot;value&quot; (in this case, 4)</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(<span class="dt">size_t</span> i{}; i &lt; <span class="kw">sizeof</span>(value); ++i)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>        stream &lt;&lt; ptr[i];  <span class="co">// Note that ptr[i] is a uint8_t</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div></li>
</ul>
</section>
<section id="biglittle-endian" class="slide level1">
<h1>Big/little endian?</h1>
<ul>
<li><p>Nella terza riga del file PFM bisogna scrivere <code>1.0</code> o <code>-1.0</code> a seconda della <em>endianness</em>.</p></li>
<li><p>Il vostro computer molto probabilmente è un sistema <em>little-endian</em>; usate comunque questa funzione per verificarlo:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> is_little_endian() {</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint16_t</span> word{<span class="bn">0x1234</span>};</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint8_t</span> *ptr{(<span class="dt">uint8_t</span> *)&amp;word};</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ptr[<span class="dv">0</span>] == <span class="bn">0x34</span>;</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Se la funzione ritorna <code>true</code>, dovete scrivere <code>-1.0</code>, altrimenti <code>1.0</code>.</p></li>
</ul>
</section>
<section id="indicazioni-per-c-1" class="slide level1">
<h1>Indicazioni per C#</h1>
</section>
<section id="file-e-stream-2" class="slide level1">
<h1>File e stream</h1>
<ul>
<li><p>In C#, uno stream è di tipo <code>Stream</code>, che è una classe base da cui deriva <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=net-5.0"><code>FileStream</code></a> e <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.memorystream?view=net-5.0"><code>MemoryStream</code></a>;</p></li>
<li><p>Per aprire un file in scrittura, usate la keyword <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-statement"><code>using</code></a>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">var</span> img = <span class="kw">new</span> <span class="fu">HdrImage</span>(<span class="dv">7</span>, <span class="dv">4</span>);</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> (Stream fileStream = File.<span class="fu">OpenWrite</span>(<span class="st">&quot;file.pfm&quot;</span>))</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    img.<span class="fu">SavePfm</span>(fileStream);</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div></li>
</ul>
</section>
<section id="scrittura-di-dati-binari-1" class="slide level1">
<h1>Scrittura di dati binari</h1>
<ul>
<li><p>La classe <a href="https://docs.microsoft.com/en-us/dotnet/api/system.bitconverter?view=net-5.0"><code>BitConverter</code></a> implementa metodi per leggere e scrivere dati binari da stream.</p></li>
<li><p>Il seguente metodo scrive un numero floating-point a 32 bit in binario:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span> <span class="kw">static</span> <span class="dt">void</span> <span class="fu">writeFloat</span>(Stream outputStream, <span class="dt">float</span> value)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">var</span> seq = BitConverter.<span class="fu">GetBytes</span>(value);</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    outputStream.<span class="fu">Write</span>(seq, <span class="dv">0</span>, seq.<span class="fu">Length</span>);</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div></li>
<li><p>Esiste la variabile <code>BitConverter.IsLittleEndian</code> per decidere se scrivere <code>1.0</code> o <code>-1.0</code> nel file PFM.</p></li>
</ul>
</section>
<section id="scrittura-di-testo" class="slide level1">
<h1>Scrittura di testo</h1>
<ul>
<li><p>Il C#, a differenza del C++, distingue tra stringhe (codificate in Unicode con UTF-16) e sequenze di byte.</p></li>
<li><p>Per scrivere correttamente l’header, la cosa più semplice è creare una stringa Unicode e poi convertirla in ASCII:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="dt">var</span> header = Encoding.<span class="fu">ASCII</span>.<span class="fu">GetBytes</span>($<span class="st">&quot;PF</span><span class="sc">\n</span><span class="st">{width} {height}</span><span class="sc">\n</span><span class="st">{endianness_value}</span><span class="sc">\n</span><span class="st">&quot;</span>);</span></code></pre></div>
<p>dove <code>endianness_value</code> è un <code>double</code> che vale <code>1.0</code> oppure <code>-1.0</code>.</p></li>
</ul>
</section>
<section id="indicazioni-per-julia" class="slide level1">
<h1>Indicazioni per Julia</h1>
</section>
<section id="tipo-hdrimage" class="slide level1">
<h1>Tipo <code>HdrImage</code></h1>
<ul>
<li><p>Potete usare una <code>struct</code> o una <code>mutable struct</code>, come preferite: gli elementi di un array <code>pixel</code> in una <code>struct</code> <strong>possono</strong> essere modificati.</p></li>
<li><p>Ovviamente dovrete definire <em>funzioni</em> anziché <em>metodi</em>, visto che Julia non supporta le classi OOP.</p></li>
</ul>
</section>
<section id="file-e-stream-3" class="slide level1">
<h1>File e stream</h1>
<ul>
<li><p>In Julia, gli stream sono rappresentati come sottotipi di <code>IO</code>.</p></li>
<li><p>Invece di definire una funzione <code>savepfm</code>, fornite una nuova definizione di <a href="https://docs.julialang.org/en/v1/base/io-network/#Base.write"><code>write</code></a> usando il <em>multiple dispatch</em>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="cn">write</span>(io<span class="op">::</span><span class="dt">IO</span><span class="op">,</span> image<span class="op">::</span>HdrImage)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ...</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>In questo modo estenderete la funzione <code>write</code> (implementata da Julia per i tipi di base) anche al vostro tipo <code>HdrImage</code>.</p></li>
</ul>
</section>
<section id="scrittura-di-file-binari" class="slide level1">
<h1>Scrittura di file binari</h1>
<ul>
<li><p>Per stabilire se la macchina è <em>little endian</em> o <em>big endian</em> c’è la costante <a href="https://docs.julialang.org/en/v1/base/io-network/#Base.ENDIAN_BOM"><code>ENDIAN_BOM</code></a>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> little_endian <span class="op">=</span> <span class="cn">ENDIAN_BOM</span> <span class="op">==</span> <span class="bn">0x04030201</span></span></code></pre></div></li>
<li><p>Per convertire un numero floating-point in un intero e viceversa, c’è <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.reinterpret"><code>reinterpret</code></a>:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># On little-endian machines</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>assert reinterpret(<span class="dt">UInt32</span><span class="op">,</span> <span class="fl">1.0f0</span>) <span class="op">==</span> <span class="bn">0x3f800000</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="co"># On big-endian machines</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>assert reinterpret(<span class="dt">UInt32</span><span class="op">,</span> <span class="fl">1.0f0</span>) <span class="op">==</span> <span class="bn">0x0000803f</span></span></code></pre></div></li>
</ul>
</section>
<section id="conversioni" class="slide level1">
<h1>Conversioni</h1>
<ul>
<li><p>Si può convertire un valore intero da <em>big endian</em> o <em>little endian</em> al formato locale della macchina con le funzioni <code>ntoh</code>, <code>hton</code>, <code>ltoh</code> e <code>htol</code>.</p></li>
<li><p>La lettera <code>h</code> sta per «host», e indica la macchina su cui il programma sta girando.</p></li>
<li><p>Ovviamente su macchine <em>little endian</em> le funzioni <code>ltoh</code> e <code>htol</code> corrispondono all’identità; su macchine <em>big endian</em> ciò vale per <code>ntoh</code> e <code>hton</code>.</p></li>
</ul>
</section>
<section id="scrittura-di-testo-1" class="slide level1">
<h1>Scrittura di testo</h1>
<ul>
<li><p>Le stringhe in Julia sono di tipo <code>String</code>, e sono codificate come UTF-8</p></li>
<li><p>I caratteri sono di tipo <code>Char</code>, ma a differenza del C++ sono valori a 32 bit: in altre parole, sono <em>code point</em> Unicode salvati usando UTF-32.</p></li>
<li><p>Per convertire una stringa in una sequenza di byte, usare <a href="https://docs.julialang.org/en/v1/base/strings/#Base.transcode"><code>transcode</code></a>:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>bytebuf <span class="op">=</span> transcode(<span class="dt">UInt8</span><span class="op">,</span> <span class="st">&quot;PF</span><span class="sc">\n</span><span class="st">$width $height</span><span class="sc">\n</span><span class="st">$endianness</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="cn">open</span>(<span class="st">&quot;out.pfm&quot;</span><span class="op">,</span> <span class="st">&quot;wb&quot;</span>) <span class="kw">do</span> io</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="cn">write</span>(io<span class="op">,</span> bytebuf)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ...</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div></li>
</ul>
</section>
<section id="indicazioni-per-kotlin" class="slide level1">
<h1>Indicazioni per Kotlin</h1>
</section>
<section id="tipo-hdrimage-1" class="slide level1">
<h1>Tipo <code>HdrImage</code></h1>
<ul>
<li><p>Potete crearlo con una <em>data class</em>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> HdrImage(<span class="kw">val</span> <span class="va">width</span>: <span class="dt">int</span>, <span class="kw">val</span> <span class="va">height</span>: <span class="dt">int</span>, <span class="kw">var</span> <span class="va">pixels</span>: <span class="dt">Array</span>&lt;<span class="va">Color</span>&gt;)</span></code></pre></div></li>
<li><p>Per l’array di colori usate un tipo <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/"><code>Array&lt;Color&gt;</code></a>, che è funzionalmente simile a <code>std::vector&lt;Color&gt;</code> in C++. Attenzione alla sintassi per inizializzarlo:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Array of 5 elements, each being black</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>val arr1 = Array&lt;Color&gt;(<span class="dv">5</span>) { Color(<span class="fl">0.0</span><span class="bu">f</span>, <span class="fl">0.0</span><span class="bu">f</span>, <span class="fl">0.0</span><span class="bu">f</span>) }</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Array of 5 elements, with shares of red of increasing brightness</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>val arr2 = Array&lt;Color&gt;(<span class="dv">5</span>) { index -&gt; Color(index, <span class="fl">0.0</span><span class="bu">f</span>, <span class="fl">0.0</span><span class="bu">f</span>) }</span></code></pre></div></li>
</ul>
</section>
<section id="file-e-stream-4" class="slide level1">
<h1>File e stream</h1>
<ul>
<li><p>Kotlin (e Java) hanno le classi <a href="https://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html"><code>InputStream</code></a> e <a href="https://docs.oracle.com/javase/7/docs/api/java/io/OutputStream.html"><code>OutputStream</code></a> (in <code>java.io</code>) per rappresentare uno stream. Queste vanno bene per i prototipi di <code>writeFloat</code> e <code>writePfm</code>.</p></li>
<li><p>Per aprire un file in scrittura c’è <a href="https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html"><code>FileOutputStream</code></a>, che restituisce direttamente uno stream.</p></li>
<li><p>Stream in memoria si creano con <a href="https://docs.oracle.com/javase/7/docs/api/java/io/ByteArrayOutputStream.html"><code>ByteArrayOutputStream</code></a>.</p></li>
<li><p>Per aprire un file, operare su esso e chiuderlo c’è <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/use.html"><code>use</code></a>, simile a <code>using</code> in C#:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>FileOutputStream(<span class="st">&quot;out.pfm&quot;</span>).use {</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    outStream -&gt; outStream.write(...)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div></li>
</ul>
</section>
<section id="scrittura-di-file-binari-1" class="slide level1">
<h1>Scrittura di file binari</h1>
<ul>
<li><p>Per scrivere/leggere valori in formato binario c’è la classe <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html"><code>ByteBuffer</code></a> in <code>java.nio</code>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">writeFloatToStream</span>(<span class="va">stream</span>: <span class="dt">OutputStream</span>, <span class="va">value</span>: <span class="dt">Float</span>) {</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    stream.write(ByteBuffer.allocate(<span class="dv">4</span>).putFloat(value).array())</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div></li>
<li><p>Controllare la <em>endianness</em> della macchina su cui gira il programma è possibile con la classe <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/ByteOrder.html"><code>ByteOrder</code></a>, sempre in <code>java.nio</code>:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">isBigEndian</span> = ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN)</span></code></pre></div></li>
</ul>
</section>
<section id="scrittura-di-testo-2" class="slide level1">
<h1>Scrittura di testo</h1>
<ul>
<li><p>Kotlin rappresenta internamente le stringhe di caratteri usando la codifica UTF-16 (come Java).</p></li>
<li><p>Per trasformare la codifica in ASCII e poterla salvare in un file binario, si può invocare il metodo <code>toByteArray()</code>:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">header</span> = <span class="st">&quot;PF</span><span class="sc">\n</span><span class="st">$width $height</span><span class="sc">\n</span><span class="st">$endianness</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>stream.write(header.toByteArray())</span></code></pre></div></li>
</ul>
</section>
    </div>
  </div>

  <script src="https://unpkg.com/reveal.js@^4//dist/reveal.js"></script>

  // reveal.js plugins
  <script src="https://unpkg.com/reveal.js@^4//plugin/notes/notes.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/search/search.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/zoom/zoom.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display a presentation progress bar
        progress: true,
        // Display the page number of the current slide
        slideNumber: true,
        // Push each slide change to the browser history
        history: true,
       // Parallax background image
       parallaxBackgroundImage: './media/background.png', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"
        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1440,
        height: 810,

        // reveal.js plugins
        plugins: [
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script src="js/asciinema-player.js"></script>
    </body>
</html>
