<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Maurizio Tomasi maurizio.tomasi@unimi.it">
  <title>Esercitazione 3</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/theme/white.css" id="theme">
  <link rel="stylesheet" href="./css/custom.css"/>
  <link rel="stylesheet" href="./css/asciinema-player.css"/>
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Esercitazione 3</h1>
  <p class="subtitle">Calcolo numerico per la generazione di immagini fotorealistiche</p>
  <p class="author">Maurizio Tomasi <a href="mailto:maurizio.tomasi@unimi.it" class="email">maurizio.tomasi@unimi.it</a></p>
</section>

<section id="scritturalettura-di-file" class="slide level1">
<h1>Scrittura/lettura di file</h1>
</section>
<section id="file-pfm" class="slide level1">
<h1>File PFM</h1>
<ul>
<li><p>La classe <code>HdrImage</code> deve essere in grado di caricare e salvare immagini PFM.</p></li>
<li><p>Abbiamo visto che i file PFM sono scritti in forma <em>binaria</em>, anche se includono parti di testo.</p></li>
<li><p>In che modo i linguaggi di programmazione che usiamo supportano l’accesso ai file?</p></li>
<li><p>Come distinguere tra file binari e testuali?</p></li>
</ul>
</section>
<section id="accesso-ai-file-in-python" class="slide level1">
<h1>Accesso ai file in Python</h1>
<p><asciinema-player src="./cast/binary-text-files-75x25.cast" cols="75" rows="25" font-size="medium"></asciinema-player></p>
</section>
<section id="file-di-testobinari" class="slide level1">
<h1>File di testo/binari</h1>
<ul>
<li>Non è possibile in generale dire se un file è codificato in forma testuale o binaria.</li>
<li>Le estensioni dei file possono essere usate per capire il formato (ma si possono sempre prendere svarioni!).</li>
<li>Python mostra che file binari usano tipi di dati (<code>b"Hello, world!\n"</code>) diversi da quelli dei file di testo (<code>"Hello, world!\n"</code>).</li>
<li>Tutti i linguaggi (Python 3, Julia, C#, Kotlin, etc.) supportano nativamente Unicode e gestiscono correttamente questa differenza…</li>
<li>…con l’eccezione del C++ (<a href="https://stackoverflow.com/questions/31302506/stdu32string-conversion-to-from-stdstring-and-stdu16string">è</a> <a href="https://stackoverflow.com/questions/17103925/how-well-is-unicode-supported-in-c11">una</a> <a href="https://stackoverflow.com/questions/2259544/is-wchar-t-needed-for-unicode-support">triste</a> <a href="https://stackoverflow.com/questions/48816848/what-is-the-efficient-standards-compliant-mechanism-for-processing-unicode-usin">storia</a>).</li>
</ul>
</section>
<section id="immagini-pfm" class="slide level1">
<h1>Immagini PFM</h1>
<ul>
<li><p>Scrivere file PFM è relativamente banale, perché hanno un <a href="http://www.pauldebevec.com/Research/HDR/PFM/">formato</a> molto semplice (decisamente più semplice dei file PPM visti a lezione!)</p></li>
<li><p>Un file PFM deve iniziare con questi caratteri (tutti ASCII, quindi non dobbiamo preoccuparci di Unicode):</p>
<pre class="text"><code>PF
width height
±1.0</code></pre>
<p>dove <code>width</code> ed <code>height</code> sono la larghezza (numero di colonne) e l’altezza (numero di righe) dell’immagine; seguono poi i valori RGB in binario.</p></li>
<li><p>I ritorni a capo vanno codificati come <code>\n</code> (non c’è ambiguità Windows/DOS/Linux/etc. come per i file di testo).</p></li>
</ul>
</section>
<section id="il-numero-1.0" class="slide level1">
<h1>Il numero <code>±1.0</code></h1>
<ul>
<li><p>La terza riga dell’header del file deve contenere <code>1.0</code> oppure <code>-1.0</code>.</p></li>
<li><p>Questo numero serve per segnalare il modo in cui ciascuna delle componenti RGB di un colore (floating-point a 32 bit) viene codificata:</p>
<ol type="1">
<li>Il valore <code>1.0</code> indica che si usa la codifica <em>big endian</em>;</li>
<li>Il valore <code>-1.0</code> indica che si usa la codifica <em>little endian</em>.</li>
</ol></li>
</ul>
</section>
<section id="numeri-in-binario" class="slide level1">
<h1>Numeri in binario</h1>
<ul>
<li><p>Per scrivere numeri in binario, ogni linguaggio offre una serie di opzioni.</p></li>
<li><p>In Python basta usare <code>import struct</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _write_float(stream, value):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Meaning of &quot;&lt;f&quot;:</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># &quot;&lt;&quot;: little endian</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># &quot;f&quot;: single-precision floating point value (32 bit)</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    stream.write(struct.pack(<span class="st">&quot;&lt;f&quot;</span>, value))</span></code></pre></div></li>
</ul>
</section>
<section id="api-di-hdrimage" class="slide level1">
<h1>API di <code>HdrImage</code></h1>
<ul>
<li><p>Il modo in cui un tipo di dato o una funzione deve essere usato dal programmatore si chiama <em>Application Program Interface</em> (API).</p></li>
<li><p>Nel nostro caso, la API per scrivere un file PFM consiste nel modo in cui invocheremmo una funzione <code>write_pfm</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Our API requires the name of the file</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>img.write_pfm(<span class="st">&quot;output_file.pfm&quot;</span>)</span></code></pre></div></li>
<li><p>Il tipo di API dovrebbe essere modellato anche in funzione dei test che si devono scrivere su di essa.</p></li>
</ul>
</section>
<section id="test-ed-api" class="slide level1">
<h1>Test ed API</h1>
<ul>
<li><p>Consideriamo il caso di <code>write_pfm</code>. Come dovremmo scrivere un test su questa funzione?</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>img <span class="op">=</span> HdrImage(<span class="dv">7</span>, <span class="dv">4</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>img.write_pfm(<span class="st">&quot;output_file.pfm&quot;</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> ...  <span class="co"># Now what?</span></span></code></pre></div></li>
<li><p>Se la funzione scrive su file, vuol dire che dovremmo poi <em>caricare</em> il file e verificare che sia stato scritto correttamente.</p></li>
<li><p>Ciò significa che finché non abbiamo una routine parallela <code>read_pfm</code> non possiamo testare <code>write_pfm</code>?</p></li>
</ul>
</section>
<section id="gestione-dei-file" class="slide level1">
<h1>Gestione dei file</h1>
<ul>
<li><p>Dobbiamo investigare meglio il modo in cui i file possono essere manipolati nei programmi.</p></li>
<li><p>Potete pensare a un file binario come a un vettore (array monodimensionale) di byte, in sequenza uno dopo l’altro. (Un file testuale è lo stesso, ma nella codifica UTF è una sequenza di <em>code point</em> anziché byte, e la cosa è un po’ più complicata).</p></li>
<li><p>I linguaggi moderni introducono una astrazione: lo <em>stream</em>.</p></li>
<li><p>Questa astrazione è molto utile nei test.</p></li>
</ul>
</section>
<section id="file-e-stream" class="slide level1">
<h1>File e stream</h1>
<ul>
<li><p>Semplificando, uno <em>stream</em> è un oggetto in grado di compiere queste operazioni:</p>
<ol type="1">
<li>Restituire un byte alla volta leggendolo da una sequenza;</li>
<li>Scrivere un byte alla volta, aggiungendolo in coda a quelli già scritti.</li>
</ol></li>
<li><p>Queste due operazioni sono quelle che tipicamente si fanno sui file, ma uno <em>stream</em> è applicabile anche ad altri contesti:</p>
<ol type="1">
<li>Una connessione di rete a un server remoto funziona come uno stream;</li>
<li>La stessa memoria RAM può essere considerata come uno stream; di conseguenza, una sequenza di byte in memoria può essere vista come uno stream, se il linguaggio lo supporta.</li>
</ol></li>
</ul>
</section>
<section id="esempio-in-python" class="slide level1">
<h1>Esempio in Python</h1>
<p><asciinema-player src="./cast/files-streams-75x25.cast" cols="75" rows="25" font-size="medium"></asciinema-player></p>
</section>
<section id="stream-api-e-test" class="slide level1">
<h1>Stream, API e test</h1>
<ul>
<li><p>Potremmo pensare di modificare la nostra API in modo che scriva in un generico stream, come l’esempio <code>write_hello</code> nel video:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>stream <span class="op">=</span> CreateSomeStream(...)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>img.write_pfm(stream)</span></code></pre></div></li>
<li><p>Quando il programma è in esecuzione, faremo in modo che <code>stream</code> sia un file vero.</p></li>
<li><p>Quando dobbiamo eseguire un test, possiamo invece fare in modo che <code>stream</code> sia una variabile in memoria. I byte non verranno quindi scritti su file, ma mantenuti in un vettore di byte, su cui eseguiremo degli <code>assert</code>.</p></li>
</ul>
</section>
<section id="il-metodo-write_pfm" class="slide level1">
<h1>Il metodo <code>write_pfm</code></h1>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> write_pfm(<span class="va">self</span>, stream):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The PFM header, as a Python string (UTF-8)</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    header <span class="op">=</span> <span class="ss">f&quot;PF</span><span class="ch">\n</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>width<span class="sc">}</span><span class="ss"> </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>height<span class="sc">}</span><span class="ch">\n</span><span class="ss">-1.0</span><span class="ch">\n</span><span class="ss">&quot;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert the header into a sequence of bytes</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    stream.write(header.encode(<span class="st">&quot;utf-8&quot;</span>))</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Write the image (bottom-to-up, left-to-right)</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">reversed</span>(<span class="bu">range</span>(<span class="va">self</span>.height)):</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.width):</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>            color <span class="op">=</span> <span class="va">self</span>.get_pixel(x, y)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>            _write_float(stream, color.r)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>            _write_float(stream, color.g)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>            _write_float(stream, color.b)</span></code></pre></div>
</section>
<section id="immagine-per-i-test" class="slide level1">
<h1>Immagine per i test</h1>
<ul>
<li><p>Ho creato due file PFM con queste caratteristiche:</p>
<ul>
<li><p>Uno è codificato come <em>little endian</em>, l’altro come <em>big endian</em>;</p></li>
<li><p>Matrice dei colori (RGB) di dimensione 3×2 pixel:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>#1</th>
<th>#2</th>
<th>#3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>#A</td>
<td>(10, 20, 30)</td>
<td>(40, 50, 60)</td>
<td>(70, 80, 90)</td>
</tr>
<tr class="even">
<td>#B</td>
<td>(100, 200, 300)</td>
<td>(400, 500, 600)</td>
<td>(700, 800, 900)</td>
</tr>
</tbody>
</table></li>
</ul></li>
<li><p>È utile che abbiate i file sul vostro disco. Scaricateli con nome <a href="./media/reference_le.pfm"><code>reference_le.pfm</code></a> e <a href="./media/reference_be.pfm"><code>reference_be.pfm</code></a> e salvateli nel vostro repository, possibilmente nella stessa directory dei test.</p></li>
</ul>
</section>
<section id="scrittura-del-test-13" class="slide level1">
<h1>Scrittura del test (1/3)</h1>
<p>Il primo approccio è quello di leggere il file <code>reference_le.pfm</code> e confrontarlo col file che <em>sarebbe</em> stato scritto da <code>write_pfm</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>img <span class="op">=</span> HdrImage(<span class="dv">3</span>, <span class="dv">2</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>img.set_pixel(<span class="dv">0</span>, <span class="dv">0</span>, Color(<span class="fl">1.0e1</span>, <span class="fl">2.0e1</span>, <span class="fl">3.0e1</span>)) <span class="co"># Each component is</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>img.set_pixel(<span class="dv">1</span>, <span class="dv">0</span>, Color(<span class="fl">4.0e1</span>, <span class="fl">5.0e1</span>, <span class="fl">6.0e1</span>)) <span class="co"># different from any</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>img.set_pixel(<span class="dv">2</span>, <span class="dv">0</span>, Color(<span class="fl">7.0e1</span>, <span class="fl">8.0e1</span>, <span class="fl">9.0e1</span>)) <span class="co"># other: important in</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>img.set_pixel(<span class="dv">0</span>, <span class="dv">1</span>, Color(<span class="fl">1.0e2</span>, <span class="fl">2.0e2</span>, <span class="fl">3.0e2</span>)) <span class="co"># tests!</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>img.set_pixel(<span class="dv">1</span>, <span class="dv">1</span>, Color(<span class="fl">4.0e2</span>, <span class="fl">5.0e2</span>, <span class="fl">6.0e2</span>))</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>img.set_pixel(<span class="dv">2</span>, <span class="dv">1</span>, Color(<span class="fl">7.0e2</span>, <span class="fl">8.0e2</span>, <span class="fl">9.0e2</span>))</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">&quot;reference_le.pfm&quot;</span>, <span class="st">&quot;wb&quot;</span>) <span class="im">as</span> inpf:</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    reference_bytes <span class="op">=</span> inpf.readall()</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>buf <span class="op">=</span> BytesIO()</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>img.write_pfm(buf)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co"># This assumes that write_pfm uses little endian</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> buf.getvalue() <span class="op">==</span> reference_bytes</span></code></pre></div>
</section>
<section id="scrittura-dei-test-23" class="slide level1">
<h1>Scrittura dei test (2/3)</h1>
<p>Ma se eseguiamo <code>xxd</code> sul file <code>reference_le.pfm</code>, possiamo ottenere la sequenza di valori dei byte nel formato C/C++:</p>
<pre class="text"><code>$ xxd -i reference_le.pfm
unsigned char reference_le_pfm[] = {
  0x50, 0x46, 0x0a, 0x33, 0x20, 0x32, 0x0a, 0x2d, 0x31, 0x2e, 0x30, 0x0a,
  0x00, 0x00, 0xc8, 0x42, 0x00, 0x00, 0x48, 0x43, 0x00, 0x00, 0x96, 0x43,
  0x00, 0x00, 0xc8, 0x43, 0x00, 0x00, 0xfa, 0x43, 0x00, 0x00, 0x16, 0x44,
  0x00, 0x00, 0x2f, 0x44, 0x00, 0x00, 0x48, 0x44, 0x00, 0x00, 0x61, 0x44,
  0x00, 0x00, 0x20, 0x41, 0x00, 0x00, 0xa0, 0x41, 0x00, 0x00, 0xf0, 0x41,
  0x00, 0x00, 0x20, 0x42, 0x00, 0x00, 0x48, 0x42, 0x00, 0x00, 0x70, 0x42,
  0x00, 0x00, 0x8c, 0x42, 0x00, 0x00, 0xa0, 0x42, 0x00, 0x00, 0xb4, 0x42
};
unsigned int reference_le_pfm_len = 84;</code></pre>
</section>
<section id="scrittura-dei-test-33" class="slide level1">
<h1>Scrittura dei test (3/3)</h1>
<p>Se inseriamo questa sequenza di byte nel nostro programma, possiamo fare un confronto diretto in memoria:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create &quot;img&quot; as in the previous case, then…</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Little-endian format</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>reference_bytes <span class="op">=</span> <span class="bu">bytes</span>([</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="bn">0x50</span>, <span class="bn">0x46</span>, <span class="bn">0x0a</span>, <span class="bn">0x33</span>, <span class="bn">0x20</span>, <span class="bn">0x32</span>, <span class="bn">0x0a</span>, <span class="bn">0x2d</span>, <span class="bn">0x31</span>, <span class="bn">0x2e</span>, <span class="bn">0x30</span>, <span class="bn">0x0a</span>,</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xc8</span>, <span class="bn">0x42</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x48</span>, <span class="bn">0x43</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x96</span>, <span class="bn">0x43</span>,</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xc8</span>, <span class="bn">0x43</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xfa</span>, <span class="bn">0x43</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x16</span>, <span class="bn">0x44</span>,</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x2f</span>, <span class="bn">0x44</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x48</span>, <span class="bn">0x44</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x61</span>, <span class="bn">0x44</span>,</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x20</span>, <span class="bn">0x41</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xa0</span>, <span class="bn">0x41</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xf0</span>, <span class="bn">0x41</span>,</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x20</span>, <span class="bn">0x42</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x48</span>, <span class="bn">0x42</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x70</span>, <span class="bn">0x42</span>,</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x8c</span>, <span class="bn">0x42</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xa0</span>, <span class="bn">0x42</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xb4</span>, <span class="bn">0x42</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="co"># No file is being read/written here!</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>buf <span class="op">=</span> BytesIO()</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>img.write_pfm(buf)</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> buf.getvalue() <span class="op">==</span> reference_bytes</span></code></pre></div>
</section>
<section id="guida-per-lesercitazione" class="slide level1">
<h1>Guida per l’esercitazione</h1>
</section>
<section id="guida-per-lesercitazione-1" class="slide level1">
<h1>Guida per l’esercitazione</h1>
<ol type="1">
<li><p>Implementate il tipo <code>HdrImage</code> con le seguenti caratteristiche:</p>
<ul>
<li>Campi <code>width</code> ed <code>height</code>, array di valori <code>Color</code>;</li>
<li>Salvataggio in formato PFM; scegliete voi se scrivere il file usando <em>big endian</em> (<code>1.0</code> nel file) o <em>little endian</em> (<code>-1.0</code>).</li>
</ul>
<p>La dichiarazione e l’implementazione di <code>HdrImage</code> andrebbe salvata in un file a parte, nella stessa directory dove settimana scorsa avete salvato il file che implementa il tipo <code>Color</code>.</p></li>
<li><p>Implementate una serie di test per le funzioni del punto precedente.</p></li>
</ol>
</section>
<section id="test-1" class="slide level1">
<h1>Test (1)</h1>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_image_creation():</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    img <span class="op">=</span> HdrImage(<span class="dv">7</span>, <span class="dv">4</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> img.width <span class="op">==</span> <span class="dv">7</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> img.height <span class="op">==</span> <span class="dv">4</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_coordinates():</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    img <span class="op">=</span> HdrImage(<span class="dv">7</span>, <span class="dv">4</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> img.valid_coordinates(<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> img.valid_coordinates(<span class="dv">6</span>, <span class="dv">3</span>)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="kw">not</span> img.valid_coordinates(<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="kw">not</span> img.valid_coordinates(<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_pixel_offset():</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    img <span class="op">=</span> HdrImage(<span class="dv">7</span>, <span class="dv">4</span>)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> img.pixel_offset(<span class="dv">0</span>, <span class="dv">0</span>) <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> img.pixel_offset(<span class="dv">3</span>, <span class="dv">2</span>) <span class="op">==</span> <span class="dv">17</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> img.pixel_offset(<span class="dv">6</span>, <span class="dv">3</span>) <span class="op">==</span> <span class="dv">7</span> <span class="op">*</span> <span class="dv">4</span> <span class="op">-</span> <span class="dv">1</span></span></code></pre></div>
</section>
<section id="test-2" class="slide level1">
<h1>Test (2)</h1>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_get_set_pixel():</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    img <span class="op">=</span> HdrImage(<span class="dv">7</span>, <span class="dv">4</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    reference_color <span class="op">=</span> Color(<span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">3.0</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    img.set_pixel(<span class="dv">3</span>, <span class="dv">2</span>, reference_color)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> are_colors_close(reference_color, img.get_pixel(<span class="dv">3</span>, <span class="dv">2</span>))</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_pfm_save():</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    img <span class="op">=</span> HdrImage(<span class="dv">3</span>, <span class="dv">2</span>)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    img.set_pixel(<span class="dv">0</span>, <span class="dv">0</span>, Color(<span class="fl">1.0e1</span>, <span class="fl">2.0e1</span>, <span class="fl">3.0e1</span>)) <span class="co"># Each component is</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    img.set_pixel(<span class="dv">1</span>, <span class="dv">0</span>, Color(<span class="fl">4.0e1</span>, <span class="fl">5.0e1</span>, <span class="fl">6.0e1</span>)) <span class="co"># different from any</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    img.set_pixel(<span class="dv">2</span>, <span class="dv">0</span>, Color(<span class="fl">7.0e1</span>, <span class="fl">8.0e1</span>, <span class="fl">9.0e1</span>)) <span class="co"># other: important in</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    img.set_pixel(<span class="dv">0</span>, <span class="dv">1</span>, Color(<span class="fl">1.0e2</span>, <span class="fl">2.0e2</span>, <span class="fl">3.0e2</span>)) <span class="co"># tests!</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    img.set_pixel(<span class="dv">1</span>, <span class="dv">1</span>, Color(<span class="fl">4.0e2</span>, <span class="fl">5.0e2</span>, <span class="fl">6.0e2</span>))</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    img.set_pixel(<span class="dv">2</span>, <span class="dv">1</span>, Color(<span class="fl">7.0e2</span>, <span class="fl">8.0e2</span>, <span class="fl">9.0e2</span>))</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This is the content of &quot;reference_le.pfm&quot; (little-endian file)</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    reference_bytes <span class="op">=</span> <span class="bu">bytes</span>([</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>        <span class="bn">0x50</span>, <span class="bn">0x46</span>, <span class="bn">0x0a</span>, <span class="bn">0x33</span>, <span class="bn">0x20</span>, <span class="bn">0x32</span>, <span class="bn">0x0a</span>, <span class="bn">0x2d</span>, <span class="bn">0x31</span>, <span class="bn">0x2e</span>, <span class="bn">0x30</span>, <span class="bn">0x0a</span>,</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>        <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xc8</span>, <span class="bn">0x42</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x48</span>, <span class="bn">0x43</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x96</span>, <span class="bn">0x43</span>,</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>        <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xc8</span>, <span class="bn">0x43</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xfa</span>, <span class="bn">0x43</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x16</span>, <span class="bn">0x44</span>,</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>        <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x2f</span>, <span class="bn">0x44</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x48</span>, <span class="bn">0x44</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x61</span>, <span class="bn">0x44</span>,</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>        <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x20</span>, <span class="bn">0x41</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xa0</span>, <span class="bn">0x41</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xf0</span>, <span class="bn">0x41</span>,</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>        <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x20</span>, <span class="bn">0x42</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x48</span>, <span class="bn">0x42</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x70</span>, <span class="bn">0x42</span>,</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>        <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0x8c</span>, <span class="bn">0x42</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xa0</span>, <span class="bn">0x42</span>, <span class="bn">0x00</span>, <span class="bn">0x00</span>, <span class="bn">0xb4</span>, <span class="bn">0x42</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>    buf <span class="op">=</span> BytesIO()</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>    img.write_pfm(buf)</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> buf.getvalue() <span class="op">==</span> reference_bytes</span></code></pre></div>
</section>
<section id="lavoro-in-gruppo" class="slide level1">
<h1>Lavoro in gruppo</h1>
<ul>
<li><p>Per iniziare il lavoro, occorre che <strong>uno solo</strong> di voi implementi lo scheletro del tipo <code>HdrImage</code>; basta la sua dichiarazione, ad esempio il file <code>.h</code> in C++.</p></li>
<li><p>Una volta fatto <code>git push</code>, prelevate in locale con <code>git pull</code>, e fate che uno di voi implementi il metodo e l’altro scriva <strong>contemporaneamente</strong> il test:</p>
<ul>
<li><code>valid_coordinates</code> + test;</li>
<li><code>pixel_offset</code> + test;</li>
<li><code>get_pixel</code>/<code>set_pixel</code> + test;</li>
<li><code>save_pfm</code> + test.</li>
</ul></li>
<li><p>Non abbiate paura di fare <em>merge commit</em>: più vi esercitate con essi, più semplice vi sarà la vita in futuro.</p></li>
</ul>
</section>
<section id="linguaggi" class="slide level1">
<h1>Linguaggi</h1>
<ul>
<li><p>Come le scorse volte, vi do una serie di indicazioni per l’implementazione nei vari linguaggi.</p></li>
<li><p>Sono presenti in ogni slide una serie di link alla documentazione del linguaggio: imparate a consultarla e a prendere familiarità col modo in cui è organizzata!</p></li>
<li><p>Via via che procederemo dovrete essere sempre più autonomi nel trovare soluzioni per il vostro linguaggio, e a diventare confidenti con la sua sintassi.</p></li>
</ul>
</section>
<section id="link-a-gather" class="slide level1">
<h1>Link a Gather</h1>
<p>Useremo il solito link: <a href="https://gather.town/app/CgOtJvyNfVKMIQ9e/LaboratorioRayTracing">gather.town/app/CgOtJvyNfVKMIQ9e/LaboratorioRayTracing</a></p>
</section>
<section id="indicazioni-per-c" class="slide level1">
<h1>Indicazioni per C++</h1>
</section>
<section id="il-tipo-hdrimage" class="slide level1">
<h1>Il tipo <code>HdrImage</code></h1>
<ul>
<li><p>Usate <code>std::vector&lt;Color&gt;</code> per l’array di colori in <code>HdrImage</code>;</p></li>
<li><p>Non c’è bisogno di implementare funzioni <code>getWidth</code>, <code>setWidth</code>, eccetera. Basta che <code>width</code>, <code>height</code> e <code>pixels</code> siano membri pubblici:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> HdrImage <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> width<span class="op">,</span> height<span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>Color<span class="op">&gt;</span> pixels<span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div></li>
<li><p>Sarebbe meglio dichiarare i metodi <code>valid_coordinates</code>, <code>pixel_index</code>, <code>get_pixel</code> e <code>set_pixel</code> nel file <code>.h</code> anziché nel <code>.cpp</code>.</p></li>
</ul>
</section>
<section id="file-e-stream-1" class="slide level1">
<h1>File e stream</h1>
<ul>
<li><p>Per accedere ai file, il C++ non è molto sofisticato: aprite il file in scrittura usando <code>std::ofstream</code>.</p></li>
<li><p>Gli stream in memoria (come <code>ByteIO</code> in Python) sono implementati da <a href="https://www.cplusplus.com/reference/sstream/stringstream/stringstream/"><code>std::stringstream</code></a> (in <code>&lt;sstream&gt;</code>):</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>stringstream<span class="op"> </span>sstr<span class="op">;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>sstr <span class="op">&lt;&lt;</span> <span class="st">&quot;PF</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> width <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&lt;</span> height <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">&lt;&lt;</span> endianness<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op"> </span>result<span class="op">{</span>sstr<span class="op">.</span>str<span class="op">()};</span>  <span class="co">// &quot;result&quot; is an ASCII string that can</span></span></code></pre></div></li>
</ul>
</section>
<section id="scrittura-di-dati-binari" class="slide level1">
<h1>Scrittura di dati binari</h1>
<ul>
<li><p>Il C++ non offre molti strumenti per scomporre una variabile <code>float</code> nei suoi quattro byte; usate questa implementazione e studiatela bene:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstdint&gt;</span><span class="pp">  </span><span class="co">// It contains uint8_t</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> Endianness <span class="op">{</span> little_endian<span class="op">,</span> big_endian <span class="op">};</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> write_float<span class="op">(</span><span class="bu">std::</span>ostream<span class="op"> &amp;</span>stream<span class="op">,</span> <span class="dt">float</span> value<span class="op">,</span> Endianness endianness<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Convert &quot;value&quot; in a sequence of 32 bit</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint32_t</span> double_word<span class="op">{*((</span><span class="dt">uint32_t</span> <span class="op">*)&amp;</span>value<span class="op">)};</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Extract the four bytes in &quot;double_word&quot; using bit-level operators</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint8_t</span> bytes<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">uint8_t</span><span class="op">&gt;(</span>double_word <span class="op">&amp;</span> <span class="bn">0xFF</span><span class="op">),</span>         <span class="co">// Least significant byte</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">uint8_t</span><span class="op">&gt;((</span>double_word <span class="op">&gt;&gt;</span> <span class="dv">8</span><span class="op">)</span> <span class="op">&amp;</span> <span class="bn">0xFF</span><span class="op">),</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">uint8_t</span><span class="op">&gt;((</span>double_word <span class="op">&gt;&gt;</span> <span class="dv">16</span><span class="op">)</span> <span class="op">&amp;</span> <span class="bn">0xFF</span><span class="op">),</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">uint8_t</span><span class="op">&gt;((</span>double_word <span class="op">&gt;&gt;</span> <span class="dv">24</span><span class="op">)</span> <span class="op">&amp;</span> <span class="bn">0xFF</span><span class="op">),</span> <span class="co">// Most significant byte</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">switch</span> <span class="op">(</span>endianness<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> Endianness<span class="op">::</span>little_endian<span class="op">:</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{};</span> i <span class="op">&lt;</span> <span class="dv">4</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span>    <span class="co">// Forward loop</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>      stream <span class="op">&lt;&lt;</span> bytes<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> Endianness<span class="op">::</span>big_endian<span class="op">:</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{</span><span class="dv">3</span><span class="op">};</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">--</span>i<span class="op">)</span>  <span class="co">// Backward loop</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>      stream <span class="op">&lt;&lt;</span> bytes<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a><span class="co">// You can use &quot;write_float&quot; to write little/big endian-encoded floats:</span></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a><span class="co">// write_float(stream, 10.0, Endianness::little_endian);</span></span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a><span class="co">// write_float(stream, 10.0, Endianness::big_endian);</span></span></code></pre></div></li>
</ul>
</section>
<section id="biglittle-endian" class="slide level1">
<h1>Big/little endian?</h1>
<ul>
<li><p>Nella terza riga del file PFM bisogna scrivere <code>1.0</code> o <code>-1.0</code> a seconda della <em>endianness</em>.</p></li>
<li><p>La funzione <code>write_float</code> della slide precedente funziona sia in un caso che nell’altro, quindi potete scegliere una possibilità e usare quella.</p></li>
<li><p>Se siete curiosi, la seguente funzione restituisce <code>true</code> quando viene eseguita su un sistema <em>little endian</em>, e <code>false</code> altrimenti:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> is_little_endian<span class="op">()</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint16_t</span> word<span class="op">{</span><span class="bn">0x1234</span><span class="op">};</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint8_t</span> <span class="op">*</span>ptr<span class="op">{(</span><span class="dt">uint8_t</span> <span class="op">*)&amp;</span>word<span class="op">};</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ptr<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="bn">0x34</span><span class="op">;</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ul>
</section>
<section id="indicazioni-per-c-1" class="slide level1">
<h1>Indicazioni per C#</h1>
</section>
<section id="file-e-stream-2" class="slide level1">
<h1>File e stream</h1>
<ul>
<li><p>In C#, uno stream è di tipo <code>Stream</code>, che è una classe base da cui deriva <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=net-5.0"><code>FileStream</code></a> e <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.memorystream?view=net-5.0"><code>MemoryStream</code></a>;</p></li>
<li><p>Per aprire un file in scrittura, usate la keyword <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-statement"><code>using</code></a>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">var</span> img <span class="op">=</span> <span class="kw">new</span> <span class="fu">HdrImage</span><span class="op">(</span><span class="dv">7</span><span class="op">,</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="op">(</span>Stream fileStream <span class="op">=</span> File<span class="op">.</span><span class="fu">OpenWrite</span><span class="op">(</span><span class="st">&quot;file.pfm&quot;</span><span class="op">))</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    img<span class="op">.</span><span class="fu">SavePfm</span><span class="op">(</span>fileStream<span class="op">);</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ul>
</section>
<section id="scrittura-di-dati-binari-1" class="slide level1">
<h1>Scrittura di dati binari</h1>
<ul>
<li><p>La classe <a href="https://docs.microsoft.com/en-us/dotnet/api/system.bitconverter?view=net-5.0"><code>BitConverter</code></a> implementa metodi per leggere e scrivere dati binari da stream.</p></li>
<li><p>Il seguente metodo scrive un numero floating-point a 32 bit in binario:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span> <span class="kw">static</span> <span class="dt">void</span> <span class="fu">writeFloat</span><span class="op">(</span>Stream outputStream<span class="op">,</span> <span class="dt">float</span> value<span class="op">)</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">var</span> seq <span class="op">=</span> BitConverter<span class="op">.</span><span class="fu">GetBytes</span><span class="op">(</span>value<span class="op">);</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    outputStream<span class="op">.</span><span class="fu">Write</span><span class="op">(</span>seq<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> seq<span class="op">.</span><span class="fu">Length</span><span class="op">);</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p>Esiste la variabile <code>BitConverter.IsLittleEndian</code> per decidere se scrivere <code>1.0</code> o <code>-1.0</code> nel file PFM.</p></li>
</ul>
</section>
<section id="scrittura-di-testo" class="slide level1">
<h1>Scrittura di testo</h1>
<ul>
<li><p>Il C#, a differenza del C++, distingue tra stringhe (codificate in Unicode con UTF-16) e sequenze di byte.</p></li>
<li><p>Per scrivere correttamente l’header, la cosa più semplice è creare una stringa Unicode e poi convertirla in ASCII:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">var</span> header <span class="op">=</span> Encoding<span class="op">.</span><span class="fu">ASCII</span><span class="op">.</span><span class="fu">GetBytes</span><span class="op">(</span>$<span class="st">&quot;PF</span><span class="sc">\n</span><span class="st">{width} {height}</span><span class="sc">\n</span><span class="st">{endianness_value}</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>dove <code>endianness_value</code> è un <code>double</code> che vale <code>1.0</code> oppure <code>-1.0</code>.</p></li>
</ul>
</section>
<section id="indicazioni-per-julia" class="slide level1">
<h1>Indicazioni per Julia</h1>
</section>
<section id="tipo-hdrimage" class="slide level1">
<h1>Tipo <code>HdrImage</code></h1>
<ul>
<li><p>Potete usare una <code>struct</code> o una <code>mutable struct</code>, come preferite: gli elementi di un array <code>pixel</code> in una <code>struct</code> <strong>possono</strong> essere modificati.</p></li>
<li><p>Ovviamente dovrete definire <em>funzioni</em> anziché <em>metodi</em>, visto che Julia non supporta le classi OOP.</p></li>
</ul>
</section>
<section id="file-e-stream-3" class="slide level1">
<h1>File e stream</h1>
<ul>
<li><p>In Julia, gli stream sono rappresentati come sottotipi di <code>IO</code>.</p></li>
<li><p>Invece di definire una funzione <code>savepfm</code>, fornite una nuova definizione di <a href="https://docs.julialang.org/en/v1/base/io-network/#Base.write"><code>write</code></a> usando il <em>multiple dispatch</em>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">write</span>(io<span class="op">::</span><span class="dt">IO,</span> image<span class="op">::</span><span class="dt">HdrImage)</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ...</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>In questo modo estenderete la funzione <code>write</code> (implementata da Julia per i tipi di base) anche al vostro tipo <code>HdrImage</code>.</p></li>
</ul>
</section>
<section id="scrittura-di-file-binari" class="slide level1">
<h1>Scrittura di file binari</h1>
<ul>
<li><p>Per stabilire se la macchina è <em>little endian</em> o <em>big endian</em> c’è la costante <a href="https://docs.julialang.org/en/v1/base/io-network/#Base.ENDIAN_BOM"><code>ENDIAN_BOM</code></a>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> little_endian <span class="op">=</span> <span class="cn">ENDIAN_BOM</span> <span class="op">==</span> <span class="bn">0x04030201</span></span></code></pre></div></li>
<li><p>Per convertire un numero floating-point in un intero e viceversa, c’è <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.reinterpret"><code>reinterpret</code></a>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># On little-endian machines</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="pp">@assert</span> <span class="fu">reinterpret</span>(<span class="dt">UInt32</span><span class="op">,</span> <span class="fl">1.0f0</span>) <span class="op">==</span> <span class="bn">0x3f800000</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co"># On big-endian machines</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="pp">@assert</span> <span class="fu">reinterpret</span>(<span class="dt">UInt32</span><span class="op">,</span> <span class="fl">1.0f0</span>) <span class="op">==</span> <span class="bn">0x0000803f</span></span></code></pre></div></li>
</ul>
</section>
<section id="conversioni" class="slide level1">
<h1>Conversioni</h1>
<ul>
<li><p>Si può convertire un valore intero da <em>big endian</em> o <em>little endian</em> al formato locale della macchina con le funzioni <code>ntoh</code>, <code>hton</code>, <code>ltoh</code> e <code>htol</code>.</p></li>
<li><p>La lettera <code>h</code> sta per «host», e indica la macchina su cui il programma sta girando.</p></li>
<li><p>Ovviamente su macchine <em>little endian</em> le funzioni <code>ltoh</code> e <code>htol</code> corrispondono all’identità; su macchine <em>big endian</em> ciò vale per <code>ntoh</code> e <code>hton</code>.</p></li>
</ul>
</section>
<section id="scrittura-di-testo-1" class="slide level1">
<h1>Scrittura di testo</h1>
<ul>
<li><p>Le stringhe in Julia sono di tipo <code>String</code>, e sono codificate come UTF-8</p></li>
<li><p>I caratteri sono di tipo <code>Char</code>, ma a differenza del C++ sono valori a 32 bit: in altre parole, sono <em>code point</em> Unicode salvati usando UTF-32.</p></li>
<li><p>Per convertire una stringa in una sequenza di byte, usare <a href="https://docs.julialang.org/en/v1/base/strings/#Base.transcode"><code>transcode</code></a>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>bytebuf <span class="op">=</span> <span class="fu">transcode</span>(<span class="dt">UInt8</span><span class="op">,</span> <span class="st">&quot;PF</span><span class="sc">\n</span><span class="st">$width $height</span><span class="sc">\n</span><span class="st">$endianness</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="fu">open</span>(<span class="st">&quot;out.pfm&quot;</span><span class="op">,</span> <span class="st">&quot;wb&quot;</span>) <span class="cf">do</span> io</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">write</span>(io<span class="op">,</span> bytebuf)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ...</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div></li>
</ul>
</section>
<section id="indicazioni-per-kotlin" class="slide level1">
<h1>Indicazioni per Kotlin</h1>
</section>
<section id="tipo-hdrimage-1" class="slide level1">
<h1>Tipo <code>HdrImage</code></h1>
<ul>
<li><p>Potete crearlo con una <em>data class</em>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> HdrImage<span class="op">(</span><span class="kw">val</span> <span class="va">width</span><span class="op">:</span> <span class="dt">int</span><span class="op">,</span> <span class="kw">val</span> <span class="va">height</span><span class="op">:</span> <span class="dt">int</span><span class="op">,</span> <span class="kw">var</span> <span class="va">pixels</span><span class="op">:</span> <span class="dt">Array</span>&lt;<span class="va">Color</span>&gt;<span class="op">)</span></span></code></pre></div></li>
<li><p>Per l’array di colori usate un tipo <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/"><code>Array&lt;Color&gt;</code></a>, che è funzionalmente simile a <code>std::vector&lt;Color&gt;</code> in C++. Attenzione alla sintassi per inizializzarlo:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Array of 5 elements, each being black</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>val arr1 <span class="op">=</span> Array<span class="op">&lt;</span>Color<span class="op">&gt;(</span><span class="dv">5</span><span class="op">)</span> <span class="op">{</span> Color<span class="op">(</span><span class="fl">0.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">)</span> <span class="op">}</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Array of 5 elements, with shares of red of increasing brightness</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>val arr2 <span class="op">=</span> Array<span class="op">&lt;</span>Color<span class="op">&gt;(</span><span class="dv">5</span><span class="op">)</span> <span class="op">{</span> index <span class="op">-&gt;</span> Color<span class="op">(</span>index<span class="op">,</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">)</span> <span class="op">}</span></span></code></pre></div></li>
</ul>
</section>
<section id="file-e-stream-4" class="slide level1">
<h1>File e stream</h1>
<ul>
<li><p>Kotlin (e Java) hanno le classi <a href="https://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html"><code>InputStream</code></a> e <a href="https://docs.oracle.com/javase/7/docs/api/java/io/OutputStream.html"><code>OutputStream</code></a> (in <code>java.io</code>) per rappresentare uno stream. Queste vanno bene per i prototipi di <code>writeFloat</code> e <code>writePfm</code>.</p></li>
<li><p>Per aprire un file in scrittura c’è <a href="https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html"><code>FileOutputStream</code></a>, che restituisce direttamente uno stream.</p></li>
<li><p>Stream in memoria si creano con <a href="https://docs.oracle.com/javase/7/docs/api/java/io/ByteArrayOutputStream.html"><code>ByteArrayOutputStream</code></a>.</p></li>
<li><p>Per aprire un file, operare su esso e chiuderlo c’è <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/use.html"><code>use</code></a>, simile a <code>using</code> in C#:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>FileOutputStream<span class="op">(</span><span class="st">&quot;out.pfm&quot;</span><span class="op">).</span>use <span class="op">{</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    outStream <span class="op">-&gt;</span> outStream<span class="op">.</span>write<span class="op">(...)</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ul>
</section>
<section id="scrittura-di-file-binari-1" class="slide level1">
<h1>Scrittura di file binari</h1>
<ul>
<li><p>Per scrivere/leggere valori in formato binario c’è la classe <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html"><code>ByteBuffer</code></a> in <code>java.nio</code>:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">writeFloatToStream</span><span class="op">(</span><span class="va">stream</span><span class="op">:</span> <span class="dt">OutputStream</span><span class="op">,</span> <span class="va">value</span><span class="op">:</span> <span class="dt">Float</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    stream<span class="op">.</span>write<span class="op">(</span>ByteBuffer<span class="op">.</span>allocate<span class="op">(</span><span class="dv">4</span><span class="op">).</span>putFloat<span class="op">(</span>value<span class="op">).</span>array<span class="op">())</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p>La classe <code>ByteBuffer</code> usa sempre la codifica <em>big endian</em>: questo è una fonte in meno di ambiguità. La cosa più comoda è quindi che nel vostro codice salviate sempre <code>1.0</code> nel file PFM (anziché <code>-1.0</code>).</p></li>
<li><p>Usate quindi come riferimento <a href="./media/reference_be.pfm"><code>reference_be.pfm</code></a>, ed evitate <code>reference_fe.pfm</code>.</p></li>
</ul>
</section>
<section id="inizializzare-bytebuffer" class="slide level1">
<h1>Inizializzare <code>ByteBuffer</code></h1>
<ul>
<li><p>I byte in Kotlin sono con segno (molto strano!)</p></li>
<li><p>Per inizializzare un array da valori esadecimali come quelli stampati da <code>xxd -i reference_be.pfm</code>, occorre una piccola funzione di aiuto:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">byteArrayOfInts</span><span class="op">(</span><span class="kw">vararg</span> <span class="va">ints</span><span class="op">:</span> <span class="dt">Int</span><span class="op">)</span> <span class="op">=</span> </span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    ByteArray<span class="op">(</span>ints<span class="op">.</span>size<span class="op">)</span> <span class="op">{</span> pos <span class="op">-&gt;</span> ints<span class="op">[</span>pos<span class="op">].</span>toByte<span class="op">()</span> <span class="op">}</span></span></code></pre></div></li>
</ul>
</section>
<section id="contenuto-di-reference_be.pfm" class="slide level1">
<h1>Contenuto di <code>reference_be.pfm</code></h1>
<div class="sourceCode" id="cb28"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">reference</span> <span class="op">=</span> byteArrayOfInts<span class="op">(</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="bn">0x50</span><span class="op">,</span> <span class="bn">0x46</span><span class="op">,</span> <span class="bn">0x0a</span><span class="op">,</span> <span class="bn">0x33</span><span class="op">,</span> <span class="bn">0x20</span><span class="op">,</span> <span class="bn">0x32</span><span class="op">,</span> <span class="bn">0x0a</span><span class="op">,</span> <span class="bn">0x31</span><span class="op">,</span> <span class="bn">0x2e</span><span class="op">,</span> <span class="bn">0x30</span><span class="op">,</span> <span class="bn">0x0a</span><span class="op">,</span> <span class="bn">0x42</span><span class="op">,</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="bn">0xc8</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x43</span><span class="op">,</span> <span class="bn">0x48</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x43</span><span class="op">,</span> <span class="bn">0x96</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x43</span><span class="op">,</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    <span class="bn">0xc8</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x43</span><span class="op">,</span> <span class="bn">0xfa</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x44</span><span class="op">,</span> <span class="bn">0x16</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x44</span><span class="op">,</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    <span class="bn">0x2f</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x44</span><span class="op">,</span> <span class="bn">0x48</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x44</span><span class="op">,</span> <span class="bn">0x61</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x41</span><span class="op">,</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    <span class="bn">0x20</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x41</span><span class="op">,</span> <span class="bn">0xa0</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x41</span><span class="op">,</span> <span class="bn">0xf0</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x42</span><span class="op">,</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    <span class="bn">0x20</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x42</span><span class="op">,</span> <span class="bn">0x48</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x42</span><span class="op">,</span> <span class="bn">0x70</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x42</span><span class="op">,</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    <span class="bn">0x8c</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x42</span><span class="op">,</span> <span class="bn">0xa0</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x42</span><span class="op">,</span> <span class="bn">0xb4</span><span class="op">,</span> <span class="bn">0x00</span><span class="op">,</span> <span class="bn">0x00</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span></code></pre></div>
</section>
<section id="scrittura-di-testo-2" class="slide level1">
<h1>Scrittura di testo</h1>
<ul>
<li><p>Kotlin rappresenta internamente le stringhe di caratteri usando la codifica UTF-16 (come Java).</p></li>
<li><p>Per trasformare la codifica in ASCII e poterla salvare in un file binario, si può invocare il metodo <code>toByteArray()</code>:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">header</span> <span class="op">=</span> <span class="st">&quot;PF</span><span class="sc">\n</span><span class="ss">$width</span><span class="st"> </span><span class="ss">$height</span><span class="sc">\n</span><span class="ss">$endianness</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>stream<span class="op">.</span>write<span class="op">(</span>header<span class="op">.</span>toByteArray<span class="op">())</span></span></code></pre></div></li>
</ul>
</section>
    </div>
  </div>

  <script src="https://unpkg.com/reveal.js@^4//dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="https://unpkg.com/reveal.js@^4//plugin/notes/notes.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/search/search.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/zoom/zoom.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: true,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'bottom-right',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: false,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'default',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'fade',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

       // Parallax background image
       parallaxBackgroundImage: './media/background.png', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1440,

        height: 810,

        // reveal.js plugins
        plugins: [
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script src="js/asciinema-player.js"></script>
    <script src="https://cdn.plot.ly/plotly-1.58.4.min.js"></script>
    <script type="text/javascript" src="./js/quantization.js"></script>
    </body>
</html>
